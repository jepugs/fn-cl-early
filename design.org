* Basic Facts

  fn is a programming language. It's qualities are

  - is a lisp
  - uses lexical scope for everything by default, but makes dynamic scope available
  - has a single namespace for functions and variables
  - designed to be succinct and expressive
  - includes a powerful data type definition system with extremely simple and consistent syntax
  - provides lightweight but robust polymorphism via protocols
  - heavily focused on providing consistent, intuitive interfaces to parallel functionality


* Implementation and Bootstraps

  - Everything is implemented in Common Lisp. The only supported implementation is SBCL. No particular
    effort is made to maintain ANSI compliance, although most of the code is ANSI anyway.
  - Most of the code is in the FN-IMPL package. This package makes use of some utilities including a $
    reader macro which behaves very similarly to the one from fn.
  - The fn package is a drop-in replacement for the CL package that turns Common Lisp into FN.
  - There will be a standard library one day. It will initially be implemented entirely in FN and
    Common Lisp, but we would like to do a lot of it in C++ (i.e. threads, networking, matrix
    operations) eventually.
  - At some point, I will likely reach the limit of what Common Lisp macros can easily do, and will
    need to begin the lengthy undertaking of writing a custom VM and interpreter. Beyond that, a
    dedicated compiler and FFI will eventually be desirable, so depending on how far I take this, we
    may need to reimplement the whole damn thing in C++.
  - The benefit to the current implementation of FN is that we can trivially use any Common Lisp
    libraries from FN source, so a crucial precondition to reimplementing the core language would be
    ensuring that it has a very rich standard library.


* Data Types

  At the center of fn is a streamlined, minimalist type system. I've done my best to keep it
  conceptually simple and to keep the number of operators supporting types small. (I think I succeeded
  on this count-- all type behavior can accessed with only 8 special operators, of which 3 are
  functions).

** Basics: Objects, Types, and Schemas

   Every value in fn is an object. Basically, this is anything you can assign a variable to. Every
   object has a type, which determines how the object behaves, and every type is described by what we
   call a schema.

   Most objects in fn can be thought of collections of addressable slots, each of which contains
   another object. The primary means of interacting with objects comes from accessing these slots.
   There are, in addition, primitive types like integers, floating-point numbers, and symbols, which
   do not have any slots, and special types like lists which have slightly different semantics from
   the usual boxes-of-slots types of objects.

   Every object has a unique type, which is represented by a symbol and may be accessed with the
   `type-of' built-in function (not yet implemented). This symbol is used to look up the corresponding
   schema, which is what we call the data structure which determines all type-specific behavior.

   Schemas in fn perform a similar function to classes in languages like Java, insofar as they contain
   the information required to create and manipulate objects of a given type. In fn, schemas are
   provide functions to construct objects of the described type, to access their slots, and to do
   pattern matching. A schema need not necessarily implement all of these features-- for instance,
   there are pattern schemas which throw an error when used for anything other than pattern matching,
   and data structures are immutable by default, meaning that the setter simply emits an error.

   There are two ways to define a new schema: the keywords `defdata' and `deftype'. `defdata' provides
   a convenient way to define record types which automatically implement sane pattern matching and
   access. `defdata' should be appropriate for the vast majority of type definitions. `deftype' is
   `defdata''s generalized big brother. Where defdata simply defines a transparent record data type,
   deftype creates a schema with private internal slots and user-defined methods for construction,
   access, and pattern matching. The syntax for `defdata' is demonstrated below:

   #+BEGIN_SRC fn
     ;; in general, defdata syntax is:
     (defdata NAME (CONSTRUCTOR-ARGS ...) OPTIONS ...)
     ;; the slot names are determined automatically from the constructor argument list

     ;;; Examples:
     ;; Type with three slots: x, y, and z. The constructor takes three positional arguments
     (defdata Vec3 (x y z))
     ;; Type with two slots: name and mail. The constructor takes two required keyword arguments
     (defdata Contact (:name name :mail mail))

     ;;; Note: We use capital letters to start words in type names. However, we still use dashes for
     ;;; spaces, so e.g. String-Stream is a good type name, but string-stream, StringStream, or
     ;;; String_Stream are all bad.

     ;; make a few vectors. The constructor function shares the type name
     (def
       e1 (Vec3 1 0 0)
       u (Vec3 1 -1 1)
       v (Vec3 -1 1 0))

     ;; make a few contacts
     (def
       alice (Contact :name "Alice" :mail "alice@lose.rs")
       bob (Contact :name "Bob" :mail "bob@lose.rs"))

     ;; this function uses pattern matching to decide its behavior. Notice how the Contact pattern
     ;; corresponds directly to the argument list
     (defn mail-unless-bob (x)
       (case x
         (Contact :name "Bob" :mail m)
           (String "Oops, it's Bob")
         (Contact :name n :mail m)
           (String  "Got it, it's " m)))
   #+END_SRC

   `deftype' does not yet have its interface planned. My thought currently is actually to bake this
   functionality into defdata by adding options, such as (:construct ...), (:match ...) which can
   override the form. For instance, here's a List schema which works by using Common Lisp functions
   from within fn:

   #+BEGIN_SRC fn
      (defdata List (v)
        ;; Construct using the List form and the new keyword to set v to a CL list.
        (:construct (& contents)
          (new 'List (CL:APPLY #'CL:LIST contents)))
        ;; Match gets passed quoted pattern arguments and returns a dict of variable bindings.
        (:match (& args)
          (list-matching-code args))
        ;; Get a list of variable names from the pattern arguments. This is required for lexical variable
        ;; resolution in match forms. It's somewhat of a leaky abstraction, but I can't think of a better
        ;; way to allow general pattern matching.
        (:match-vars (& args)
          (list-match-vars-code args))
        ;; Getter just uses CL:NTH
        (:get (instance slot)
          (CL:NTH slot (slot-value instance 'cell)))
        ;; Setter uses CL:SETF
        (:set (instance slot value)
          (CL:SETF (CL:NTH slot (slot-value instance 'cell)) value)))

      ;; car and cdr use slot-value
      (defn car (list)
        (CL:CAR (slot-value list 'cell)))
      (defn cdr (list)
        (CL:CDR (slot-value list 'cell)))

      ;; example of a schema which doesn't create a constructor or getter
      (defdata SecretType (secret)
        ;; A value of false for construct causes the constructor not to be created. The object may still be
        ;; instantiated using new.
        (:construct false)
        ;; Likewise, when get is false, you must use slot-value to access slots.
        (:get false)
        ;; When set is false, the data type is immutable (this is the default). This can also be true,
        ;; which allows fields to be set using (set! (slot-values)) but not (set! (@)).
        (:set false)
        ;; When match is false, pattern matching on the schema causes an error.
        (:match false)
        )

     ;; example of a schema which doesn't implement all operations
     (defdata Unconstructible ()
       ;; This type can't be instantiated, not even using new.
       (:instantiable false))

   #+END_SRC

   This way you can choose to use to use


** Generic Operators (new, @, slot-value, set!)

   If you read the Basics section, you saw these operators floating around with no explanation. Here
   we remedy that. These four operators provide a generic object manipulation interface. Together,
   they expose sufficient functionality to create data types which have highly customized behavior.

   First of all, there is the `new' function, which takes a symbol corresponding to a type name as its
   first argument. The remaining arguments intialize the slots of the object. These arguments are the
   same as the default constructor arguments. However, when a custom constructor is specified, `new'
   still allows you to instantiate an object's slots directly, bypassing the constructor altogether.
   `new' can also be used to instantiate types with no constructor.

   `new' should only ever be used to implement custom construction behavior, not for general-purpose
   instantiation.

   Next, we'll look at the getters: `@' and `slot-value'. As with `new' and the default constructor,
   under normal circumstances, these two operators behave the same way. They both take two arguments,
   an object and a slot name, in that order, although @ may accept more arguments which will be used
   recursively to descend into the structure of an object.

   The difference is this: `slot-value' directly accesses the slots of an object, while `@' uses the
   getter code provided by the schema. An instructive example of this is the list data type. Lists
   actually do not have any slots in the current implementation, so `slot-values' will always fail on
   them. However, `@' may access the elements of a list using the natural numbers (from 0) as slot
   values. As before, `slot-value' should only be used in implementing custom type behavior, where
   `@' should be used for general purpose access.

   Finally, we arrive at `set!', our setter. Data types are immutable by default, so `set!' should be
   used sparingly for setting slot values. `set!' is the generic assignment operator. It can update
   the values of variables, but it can also write to the slots of objects using the syntax `(set! (@
   OBJECT SLOT) NEW-VALUE)' or `(set! (slot-value OBJECT SLOT) NEW-VALUE)'. As before, the latter
   should be used only in certain circumstances directly involving the type system, while the former
   is good for general purpose access.


** Polymorphism via Protocols

   Polymorphism in fn is implemented via protocols. A protocol is a group of functions, which we call
   methods, whose behavior is decided based on the types of certain arguments (generic arguments).
   Protocols are defined using `defproto'. Afterwards, the sets of types which implement each protocol
   are defined using `defimpl'. To give you a feel for the syntax, here's an example of a protocol on
   two types which is used to multiply two values (possibly non-commutatively).

   #+BEGIN_SRC fn
     ;; upper case first letters for protocol names, lowercase names for methods
     (defproto Mul (L R)
       ;; body contains method signatures where L and R are interpreted as generic arguments.
       (mul (L R)
         ;; function options (e.g. memoize, curry, type) have to go here.
         {:doc "Used by `*' to decide how to multiply objects of arbitrary types."}))

     ;; implement multiplication of strings by integers on the right. Integers duplicate the string n
     ;; times, so (mul "string" 4) => "stringstringstringstring". Multiplication is commutative by
     ;; default.
     (defimpl Mul (String Int)
       ;; method syntax is parallel
       (mul (str i)
         ;; inefficient recursive algorithm
         (if (<= i 0)
           ""
           (concat str (mul str (- i 1))))))

     ;; finally, we can use the Mul function to decide if two types implement it:
     (Mul 'String 'Int) ;=> true
     (Mul 'Int 'String) ;=> false
     (Mul 'Int 'Int) ;=> true (provided by fn)
   #+END_SRC

   There's no need to limit ourselves to a single method per protocol, however this is often
   sufficient, and we don't encourage abusing protocols. Use them where the abstraction is
   appropriate.


* Pattern Matching (TODO)


* New argument lists

  Common Lisp's syntax for argument lists is great because it's unambiguous,
  easy to remember, and powerful. Common Lisp's syntax for argument lists is bad
  because it's verbose, ugly (subjective), and does not run parallel to the
  syntax for function calls.

  The goal with FN's new lambda lists is to give the language a more coherent
  interface than what we currently have in Common Lisp. That is, we would like
  the syntax for argument lists to look more like actual function calls.

  For starters, we simplify the types of arguments that we allow in FN. We now
  only have optional, positional, keyword and rest arguments, with the
  restriction that keyword and rest arguments can not be mixed in the same
  argument list. Next, replace &REST with &. It says enough. Moreover, we forget
  about &OPTIONAL and &KEY-- optional forms are now just lists, and keyword
  forms are actual keywords. This is a taste of our new argument lists:

  #+BEGIN_SRC fn
  (defn func (positional-arg (optional-arg "init") :keyword-arg (keyword-arg "key-init"))
    (function-body))
  #+END_SRC

  And here are some translations from Common Lisp:

  #+BEGIN_SRC fn
  (defun operator (operand0 &rest operands) ...)
  ;; => (in FN)
  (defn operator (operand0 & operands) ...)

  (defun log (x &optional (base 10)) ...)
  ;; => lists replace &optional
  (defn log (x (base 10)) ...)

  (defun sort (seq &key (test #'< test-p) (ascending t)) ...)
  ;; => keyword arguments replace &key
  (defn sort (seq :test (test #'<) :ascending (ascending t)) ...)
  #+END_SRC

  This also gives us the ability to define non-optional keyword arguments via
  the syntax (:keyword-arg keyword-arg) (where the arg is a symbol, not a list).

  #+BEGIN_SRC fn
  ;; define a function requiring a keyword argument
  (defn func (:req-key req-key :opt-key (opt-key "default")) 
    (function-body))

  (func) ;=> error (needs req-key)
  (func :req-key 6) ;=> okay (opt-key = "default")
  (func :opt-key 9) ;=> error (needs req-key)
  (func :req-key 6 :opt-key 9) ;=> okay
  #+END_SRC

  These non-optional keywords are especially useful when defining new data types
  via defdata.


* FN Code Conventions

  This one has personal significance because readability is always one of the
  biggest complaints normies have about Lisp. We address this in almost every
  aspect of fn's design, for instance by keeping the core language very small,
  reusing interfaces wherever possible (see arg lists), and minimizing the paren
  count (e.g. by removing extra parens from cond and let). However, having a
  clear set of code conventions is also very important for writing readable
  code.

  I have two problems with how most LISP code is formatted (other than all the
  bad naming conventions):

  - Too many levels of indentation
  - Too many consecutive closing parens

  That's it.


** Indentation

Indentation is arguably the most important convention to decide upon, because it
is the most complicated thing to implement in the text editor. My emacs mode
should be able to automatically indent all built-in forms as well as normal
function calls

All macro bodies should be indented two spaces relative to the opening paren
that started them. Lines longer than 80 characters should be avoided. To be
clear, not all macros have bodies, and forms such as `and' and `or' can be
indented according to normal function rules.


*** Function arguments

    #+BEGIN_SRC fn
    
    #+END_SRC


*** Definitions

    At the time of writing, there are 20 special operators planned for fn. Eight
    of those are definitions, although def, def*, and defvar are different
    because they can bind. For these operators, observe the conventions for
    alternating pairs operators. Otherwise, we will observe the following
    conventions:

    #+BEGIN_SRC fn
    (defform name arg-list ;omit arg-list where applicable
      ;; indent two spaces for all body forms
      (body-line1)
      (body-line2)) ;closing paren on same line

    ;; e.g.
    (defdata Contact (:name name :mail mail))

    (defn factorial (n)
      (if (= n 0)
      ;; two levels indent for if, see other special forms
      1
      (* n (factorial (- n 1)))))
    #+END_SRC


*** Alternating pairs

    Many of our special forms contain lists whose arguments are processed
    pairwise. For example, the variable definition part of let and the bodies of
    cond and case. For these we observe the following convention: either put
    both expressions on the same line, or else indent the second component of
    each pair two levels deeper than the one before.

    #+BEGIN_SRC fn
    (case lst
      [] "empty" ;short clauses go on one line
      [[] & _]   ;longer clauses go on the next line
        (string "empty head found") ;indent 2 spaces deeper
      (hd & tl)  ;put multiline consequences in a do block
        (do
          (do-something-with-head hd)
          (long-expression-with-tail tl)))

    (let (1liner (short-expr) ;short definitions on one line
          multi-liner ;align with previous variable name
            (much-longer-expression :with-params some-params)
          (pattern a _) ;here we could use either convention
            (do-something-with a))
      (do-something-with-these-vars 1liner multi-liner))
    #+END_SRC


* design ideas

  - parentheses denote code objects. quote and backquote return code objects
    that can be used by the program. Unquoted code is evaluated. Code objects
    are made out of primitive types, symbols, and conses.
  - square brackets are for lists (and consequently trees). Lists are singley
    linked in classic lisp fashion. We use the ampersand (&) instead of the dot
    for inline conses.
  - rejected idea (don't repeat this mistake): & is a function so (& a b c) :=
    [a b & c].
  - make objects with the keyword NEW. Schemas decide their own constructor
    parameters
  - Every schema has a corresponding pattern matcher
  - When looking up an object's schema, we will use the class name of the object
    as the key for a hash table. This is to make the lookup as fast as possible.


* Standard Library
  
** Built-in data types (and how they're made)

   - bool :: true or false (literals)
   - int :: integer (literal)
   - float :: floating-point number (literal)
   - string :: utf-8 string, is-string (literal)
   - list :: singley-linked list (list and cons functions)
   - vec :: fixed-width vector (vector function)
   - dict :: (immutable?) dictionary, (dict function)
   - fn :: function. Make 'em with fn. Would like to parameterize this type
           eventually
   - bytes :: vector of literal bytes. Used for FFI biz. Not sure how to
              construct it (yet)

              
** Type tests

   - is-bool
   - is-int 
   - is-float
   - is-string 
   - is-char :: check for characters
   - is-list
   - is-vec
   - is-dict
   - is-bytes


** Things to copy from other people:

   - arrays, linalg, random (from NumPy)
   - map, reduce, filter, zip (from every good pl)
   - threading macros (from Clojure)

   
* list of syntax characters

- () for code
- [] creates lists (evaluates arguments)
- {} creates dicts (evaluates args)
- $ creates anonymous functions (only when alone)
- # used for characters and dispatch (rethink?)
- ' quoting
- ` and , quasiquoting
- : keywords, symbol modules
- \ escape next char
- ; comments


non-alphanumeric characters used in identifiers

- ! as a suffix indicates mutation (it's like we're yelling!)
- @ by itself is the universal accessor
- & by itself denotes rest arguments
- *, +, /, =, <, >, _, - (normal identifiers)


Special characters from CL that are no longer special:

- || for multi-char escapes
- . for dotted lists (what a dumb useless thing)


Characters reserved for future extensions

- ~, ^, %, ?, ., and |


*Ideas*

- Perhaps programmers should be encouraged to make use of $-args in their own
  macros in order to further promote consistency in the language, for instance
  to automatically create gensyms in macros.
- Maybe drop the ! convention-- since global variables are immutable by default,
  it is less crucial to keep track of state changes. Maybe not, though, as
  constant globals can still contain mutable data structures (we'll think about
  that though-- possibly add an immutable flag to instances? (would have to make
  lists, dicts immutable by default))
- It would be cool if we could drop the # syntax altogether-- presently all it
  does is read in characters and alternative-radix numbers (could be done with
  0x00 syntax). Perhaps we could do this by taking the Javascript approach
  (strings of length 1 are single characters)
- I also like single quoting for string syntax, but I think it's important to
  lisp that we leave quoting characters alone. It's not such a hardship to use
  double quotes-- the idiots using C and Java have been doing it for ages (smart
  people have to do it too).


* Versions

** Version conventions

We will use the convention three number (major.minor.patch) release numbering.

There are special rules for major version 0, but in general we will

- increment the patch number for substantial bug fixes, optimizations, and minor interface
  improvements not related to the core language or the standard library (i.e. changes to the
  highlighting and the emacs mode)
- increment the minor version number for any compatibility breaking changes to the standard library,
  the addition of new library features, minor language changes, and additions to the language that do
  not break existing code (except for possibly introducing name collisions). Also increment it for
  changes to the tools and platform that don't break old interfaces
- increment the major version number for substantial changes or additions to the core language,
  platform, and tooling. Example: when we ditch Common Lisp and move on to our own custom vm, this
  will be a major version change.

Patch increments will happen on an as needed basis. I intend to test fn by writing a lot of code in
it. I'll fix bugs as I go and bump the patch number when I feel like I'm at a logical place to do so.
Don't expect to see a ton of these early on. Minor and major version releases will have milestone
lists, and I will only increment the version number after reaching all the goals.

Since we don't expect to have a stable language or standard library for some time, we will change the
rules for the version 0 release series, with the goal of having a stable language, library, and tools
by the time we hit 1.0.


** Version 0.0.0 Milestones

   The goal for version 0.0.0 is to have the core language fully implemented except for symbols and
   modules. Our milestones are

   - 90% implementation of data structures (defdata) and protocols (defimpl, defproto). We'll be
     missing the generalized deftype, and we'll be missing more sophisticated options
   - emacs major mode with mostly-correct indentation and syntax highlighting
   - all core special operators implemented: def, def*, defdata, defimpl, defmacro, defn, defproto,
     defvar, @, and, case, cond, do, if, fn, let, new, set!, quote, quasiquote
   - case sensitive reader with delimiter, $, and quoting implemented
   - fn package that exposes all language forms. I should be able to do (fn-impl:boot-fn) and write fn
     code.
   - making # and . into normal characters


** Version 0.1 Milestones

   For version 0.1, we want to have the core language and tooling fully implemented. If we do it
   right, then from this version all the way up to version 1.0, the only substantial changes will be
   in module system and standard library.

   - FN-READ, FN-EVAL, and FN-PRINT functions in the CL-FN package that let Common Lisp code embed fn
   - signal system for error handling and control flow
   - more general type definition
   - stable core language syntax, meaning we have to address quasiquoting, the colon, and the dot
   - differentiation of the empty list and false
   - emacs command to send fn code to a SLIME repl
   - change how function application works
   - add the Callable interface
   - decide on a standard library naming convention
   - add the Sequence interface and libraries
   - implementation of input/output streams
   - automatic type checks via type annotations


   *Notable Missing Features*

   - module system
   - doc strings and help function
   - stack traces/debugging features
   - bit vectors


** Version 1.0 Milestones

   Version 1.0 will be a usable programming language with actual tooling and a standard library that
   lets it do pretty much anything you'd want to do in a UNIX environment. At this point, it will
   still all be Common Lisp under the hood, but that will be abstracted away to being a simple
   implementation detail. After version 1.0, we'll flesh out the standard library a bit, but the next
   big milestone will be ditching Common Lisp entirely in favor of C++ and LLVM.

   Once I reach the first release candidate, I'm going to take a break and develop a substantial
   amount of code in fn. My first project will be a VM orchestrator. During this time, I'll be
   adjusting language features, fixing bugs, and extending the standard library as needed.

   - I will have written a lot of code in fn and determined that it is useful
   - the core language will be stable
   - documentation functions work
   - foreign function interface
   - module system including library path, multi-file module declaration, submodules, imports and
     qualified imports, file imports, and reloading
   - standard library includes threading, filesystem, file I/O, IPC and network sockets, system shell
     commands, subprocesses, command line arguments, and environment variables (all the usual UNIX
     stuff)
   - consistent error handling interfaces across the entire standard library
   - emacs major mode has its own shell
   - emacs mode can collapse code forms (particularly function options/doc strings)
   - immutable reimplementation of dicts
   - defdata has options and knows how to use them (i.e. mutable, immutable)
   - debugging including programmatically-accessible stack traces and breakpoints, plus global debug
     options
   - different optimization levels (i.e. disable type checks)


   *Notable Missing Features*

   - port implementation from Common Lisp to C++
   - compiler via LLVM
   - scientific and symbolic computing in the standard library
   - regex in the standard library
   - package/module manager
   - web server

