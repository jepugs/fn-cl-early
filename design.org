* Implementation and Bootstraps

  - Everything is implemented in Common Lisp. The only supported implementation
    is SBCL. No particular effort is made to maintain ANSI compliance, although
    most of the code is ANSI anyway.
  - Most of the code is in the FN-IMPL package. This package makes use of some
    features of FN (for instance, the $ reader macro), but we avoid global
    lexical variables, the fn macro, and any functionality that would shadow
    symbols in the CL package.
  - The FN package is a drop-in replacement for the CL package that turns common
    lisp into FN.
  - There will be a standard library one day. It will initially be implemented
    entirely in FN and Common Lisp, but we would like to do a lot of it in C++
    (i.e. threads, networking, matrix operations) eventually.
  - At some point, I will likely reach the limit of what Common Lisp macros can
    easily do, and will need to begin the lengthy undertaking of writing a
    custom VM and interpreter. Beyond that, a dedicated compiler and FFI will
    eventually be desirable, so depending on how far I take this, we may need to
    reimplement the whole damn thing in C++.
  - The benefit to the current implementation of FN is that we can trivially use
    any Common Lisp libraries from FN source, so a crucial precondition to
    reimplementing the core language would be ensuring that it has a very rich
    standard library.


* Schemas and Patterns

  A *schema* is the data structure that describes a data type.

  New data types in FN are usually defined with the defdata operator. Presently
  the defdata operator takes two arguments: a name and an arg list. The arg list
  follows the same syntax as FN arg lists, see the section New Lambda Lists for
  details. This arg list is the argument list for the constructor function,
  which is invoked by (new DATATYPE ARG ...).

  #+BEGIN_SRC common-lisp
    (defdata NAME ARG-LIST) ;=> (defines a data schema)

    (new NAME ARGS) ;=> makes an instance of NAME

    (@ SLOT INSTANCE) ;=> value from SLOT in INSTANCE

    (case OBJ
      (NAME PATTERN-ARG*)
        EXPR
      ...)
    ;; => if OBJ matches the schema, bind the field values to the pattern-args
    ;;    and execute EXPR
  #+END_SRC

  Data classes defined with defdata can be thought of as structs from C. That
  is to say, they are nothing but boxes of named values. The names, which are
  called slots, are the variable names from the arg list.

  #+BEGIN_SRC common-lisp
    (defdata Pair left right) ;=> defines the Pair schema

    (def my-pair (new Pair 1 2)) ;=> make a Pair

    (@ 'left my-pair) ;=> value from SLOT in INSTANCE

    (setf (@ 'right my-pair) 3) ;=> set right to 3

    (case my-pair
      (pair 0 x) (format t "0 and ~s" x)    ;not called (pattern doesn't match)
      (pair 1 x) (format t "1 and ~s" x))   ;will be called
    ;; 1 and 3
    ;;=> NIL
  #+END_SRC  


** What's in a schema?

   As you can see from above examples, schemas provide interfaces to do four
   things:

   - construct new instances of the associated type
   - access slots for such instances
   - set the values of slots
   - perform pattern matching

   A great deal of care is taken to make sure that the interfaces are very clear
   across all four of these.


** Advanced Schemas

   There are already two special schemas in fn: the list and dict schemas. On
   the implementation side of things, these schemas have class general-schema
   rather than the data-schema class used by defdata. Rather than relying on an
   arg-list, general-schema instances contain general functions that accomplish
   each task.

   #+BEGIN_SRC common-lisp
   (case [1 2 3]
     [1 _] (print '_) ;no match (not enough args)
     [1 1 x] (print x) ;no match (second arg mismatch)
     [1 & x] (print x) ;match with rest arg-- prints [2 3]
   )

   (case {:a 'a :b "b"}
     {:a 'b} (print 'b) ;no match (mismatch on :a)
     {:b "b"} (print "b") ;match-- note how not all keys are needed
   )
   #+END_SRC
  
   At some point, we will want to make general-schema functionality available to
   user programs. For now, we're not going to worry about it.


** Pattern matching semantics

   TODO



* Types and Protocols

  The type of an object can be accessed via the (type-of OBJ) built-in function.
  Types in FN are as simple as possible. Every object has a single type
  represented by a symbol. There is also a wildcard type which is represented by
  the underscore `_'. In the future, we may add parametric types.

  As with all dynamically typed languages, the extent to which the programmer
  interacts with the type system is limited. That said, fn is strongly typed
  in the sense that an error will be raised when there is an attempt to perform
  an operation on an inappropriate type.

  For now, types are all but invisible. I would like to extend the language so
  that the user can specify types for function arguments and data structure
  slots. The idea here is to automagically bake type checking into functions and
  constructors so that the coder doesn't need to type out (if (is-list x) ...).


** Built-in Types

   - list :: list
   - vector :: vector
   - string :: string
   - integer :: integer
   - char :: character


* New lambda lists

  Common Lisp's syntax for argument lists is great because it's unambiguous,
  easy to remember, and powerful. Common Lisp's syntax for argument lists is bad
  because it's verbose, ugly (subjective), and does not run parallel to the
  syntax for function calls.

  The goal with FN's new lambda lists is to give the language a more coherent
  interface than what we currently have in Common Lisp. That is, we would like
  the syntax for argument lists to look more like actual function calls.

  For starters, we simplify the types of arguments that we allow in FN. We now
  only have optional, positional, keyword and rest arguments, with the
  restriction that keyword and rest arguments can not be mixed in the same
  argument list. Next, replace &REST with &. It says enough. Moreover, we forget
  about &OPTIONAL and &KEY-- optional forms are now just lists, and keyword
  forms are actual keywords. This is a taste of our new argument lists:

  #+BEGIN_SRC fn
  (defn func (positional-arg (optional-arg "init") :keyword-arg (keyword-arg "key-init"))
    (function-body))
  #+END_SRC

  And here are some translations from Common Lisp:

  #+BEGIN_SRC fn
  (defun operator (operand0 &rest operands) ...)
  ;; => (in FN)
  (defn operator (operand0 & operands) ...)

  (defun log (x &optional (base 10)) ...)
  ;; => lists replace &optional
  (defn log (x (base 10)) ...)

  (defun sort (seq &key (test #'< test-p) (ascending t)) ...)
  ;; => keyword arguments replace &key
  (defn sort (seq :test (test #'<) :ascending (ascending t)) ...)
  #+END_SRC

  This also gives us the ability to define non-optional keyword arguments via
  the syntax (:keyword-arg keyword-arg) (where the arg is a symbol, not a list).

  #+BEGIN_SRC fn
  ;; define a function requiring a keyword argument
  (defn func (:req-key req-key :opt-key (opt-key "default")) 
    (function-body))

  (func) ;=> error (needs req-key)
  (func :req-key 6) ;=> okay (opt-key = "default")
  (func :opt-key 9) ;=> error (needs req-key)
  (func :req-key 6 :opt-key 9) ;=> okay
  #+END_SRC

  These non-optional keywords are especially useful when defining new data types
  via defdata.


* Lexical scope

  I implemented global lexical scope in Common Lisp so we can have it in fn.

  
* FN Code Conventions

  This one has personal significance because readability is always one of the
  biggest complaints normies have about Lisp. We address this in almost every
  aspect of fn's design, for instance by keeping the core language very small,
  reusing interfaces wherever possible (see arg lists), and minimizing the paren
  count (e.g. by removing extra parens from cond and let). However, having a
  clear set of code conventions is also very important for writing readable
  code.

  I have two problems with how most LISP code is formatted (other than all the
  bad naming conventions):

  - Too many levels of indentation
  - Too many consecutive closing parens

  That's it.


** Indentation

Indentation is arguably the most important convention to decide upon, because it
is the most complicated thing to implement in the text editor. My emacs mode
should be able to automatically indent all built-in forms as well as normal
function calls

All macro bodies should be indented two spaces relative to the opening paren
that started them. Lines longer than 80 characters should be avoided. To be
clear, not all macros have bodies, and forms such as `and' and `or' can be
indented according to normal function rules.


*** Function arguments

    #+BEGIN_SRC fn
    
    #+END_SRC


*** Definitions

    At the time of writing, there are 20 special operators planned for fn. Eight
    of those are definitions, although def, def*, and defvar are different
    because they can bind. For these operators, observe the conventions for
    alternating pairs operators. Otherwise, we will observe the following
    conventions:

    #+BEGIN_SRC fn
    (defform name arg-list ;omit arg-list where applicable
      ;; indent two spaces for all body forms
      (body-line1)
      (body-line2)) ;closing paren on same line

    ;; e.g.
    (defdata Contact (:name name :mail mail))

    (defn factorial (n)
      (if (= n 0)
      ;; two levels indent for if, see other special forms
      1
      (* n (factorial (- n 1)))))
    #+END_SRC


*** Alternating pairs

    Many of our special forms contain lists whose arguments are processed
    pairwise. For example, the variable definition part of let and the bodies of
    cond and case. For these we observe the following convention: either put
    both expressions on the same line, or else indent the second component of
    each pair two levels deeper than the one before.

    #+BEGIN_SRC fn
    (case lst
      [] "empty" ;short clauses go on one line
      [[] & _]   ;longer clauses go on the next line
        (string "empty head found") ;indent 2 spaces deeper
      (hd & tl)  ;put multiline consequences in a do block
        (do
          (do-something-with-head hd)
          (long-expression-with-tail tl)))

    (let (1liner (short-expr) ;short definitions on one line
          multi-liner ;align with previous variable name
            (much-longer-expression :with-params some-params)
          (pattern a _) ;here we could use either convention
            (do-something-with a))
      (do-something-with-these-vars 1liner multi-liner))
    #+END_SRC


* Misc functions/macros

  - with-fields, with-fields*
  - match
  - dict
  - new
  - @
  - fold, map, filter, zip


* design ideas

  - parentheses denote code objects. quote and backquote return code objects
    that can be used by the program. Unquoted code is evaluated. Code objects
    are made out of primitive types, symbols, and conses.
  - square brackets are for lists (and consequently trees). Lists are singley
    linked in classic lisp fashion. We use the ampersand (&) instead of the dot
    for inline conses.
  - rejected idea (don't repeat this mistake): & is a function so (& a b c) :=
    [a b & c].
  - make objects with the keyword NEW. Schemas decide their own constructor
    parameters
  - Every schema has a corresponding pattern matcher
  - When looking up an object's schema, we will use the class name of the object
    as the key for a hash table. This is to make the lookup as fast as possible.


* Standard Library
  
** Built-in data types (and how they're made)

   - bool :: true or false (literals)
   - int :: integer (literal)
   - float :: floating-point number (literal)
   - string :: utf-8 string, is-string (literal)
   - list :: singley-linked list (list and cons functions)
   - vec :: fixed-width vector (vector function)
   - dict :: (immutable?) dictionary, (dict function)
   - fn :: function. Make 'em with fn. Would like to parameterize this type
           eventually
   - bytes :: vector of literal bytes. Used for FFI biz. Not sure how to
              construct it (yet)


** 


** Type tests

   - is-bool
   - is-int 
   - is-float
   - is-string 
   - is-char :: check for characters
   - is-list
   - is-vec
   - is-dict
   - is-bytes


** Things to copy from other people:

   - arrays, linalg, random (from NumPy)
   - map, reduce, filter, zip (from every good pl)
   - threading macros (from Clojure)


* Experimental Zone

  This is where I'm gonna put some wild ideas that I'm not sure about.

** schemas with custom internal data structures

   eee

   
** protocols (polymorphism)

   I really like how protocols work in SML/how type classes work in Haskell.
   However, these implementations are indelibly tied to the static type system.
   Here's an example: suppose we wanted to define a sequence type class in
   Haskell. We want our sequence types to satisfy two requirements: we can
   create an iterator from any sequence, and we can get an empty version of that
   sequence. We can define our iterator and sequence typeclasses like so

   #+BEGIN_SRC haskell
   class Iterator a where
       hasNext :: a -> Bool
       iterNext :: a -> a
       iterGet :: a -> b

   class Sequence a where
       empty :: a
       iterator :: Iterator b => a -> b
       conc :: a -> a -> a

   -- example instance
   data ListIt = ListIt lst
   instance Iterator ListIt where
     hasNext (ListIt lst) = lst == []
     iterNext (ListIt lst) = ListIt (tail lst)
     iterGet (ListIt lst) = head lst

   instance Sequence [a] where
     empty = []
     iterator x = ListIt x
     conc x y = x ++ y

   #+END_SRC

   Don't try running this code. I haven't written Haskell in a while. Even so,
   this example is instructive, as it reveals some of the key features of an
   effective ADT protocol system.

   It is immediately clear that we want two new special forms to implement
   protocols. We will define protocols with defproto, and create implementations
   with defimpl. In addition, we will need to define some sort of symbol which
   corresponds to the designated type (in the Haskell example, it's the variable
   a).

   Also, we can see that the empty method is not a function. Rather, it works
   like a variable, with the type system doing the heavy lifting-- in Haskell's
   case, the compiler decides which version of empty to use based on the type
   expected in the code. Haskell is pretty cool.

   To emulate this behavior in FN, we would like a way to define a function
   (empty TYPE) which takes the type name as a symbol. E.g. (empty 'list) =>
   NIL. In addition, we will need a way to specify methods that accept arguments
   of the given type.

   I have a solution which I believe kills two birds with one stone.

 
** unified definition

   First off, let's not kid ourselves: DEFPARAMETER is too long of a name.
   DEFVAR is not so bad, but usually we want DEFPARAMETER behavior, rather than
   DEFVAR behavior.
   
   Currently, I've decided to use DEF for declarations, SET for updates, CONST
   for constants, and DEFN for functions.

   #+BEGIN_SRC common-lisp
   (defparameter x 6)
   ;; => (in FN)
   (def x 6)

   (defconstant pi 3.14)
   ;; =>
   (const pi 3.14)

   (defun log (x &optional (base 10))
     ...)
   ;; =>
   (defn log (x (base 10))
     ...)
   ;; or, equivalently, (but not until the future)
   (def log
     (fn (x (base 10))
       ...))
   #+END_SRC


** function options

   Functions look like this:

   (fn (args) body)

   We would like to customize function behavior. If the first argument of the
   function body is a dict form (denoted below with braces), and the body has
   length > 1, then we will use that dictionary as the function options:

   (fn (args)
     {:option-name option-value ...}
     body)

   Some ideas for options are:

   - :type, :optimize, :ignore, ignoreable :: replace DECLARE forms
   - :inline BOOL :: whether to inline this function
   - :curry N :: automatically curry up the first N arguments. Or, if N is true,
                 then curry all positional arguments (default: false, eqv. 0)
   - :memo BOOL :: memoize the function if true (default: false)
   - :doc STR :: docstring (only in definitions)
   - :arg-doc LIST :: argument documentation (only in definitions)


** Local definitions

   
* Immediate future


* list of special character:

- () for code
- [] creates lists (evaluates arguments)
- {} creates dicts (evaluates args)
- $ creates anonymous functions (only when alone)
- # used for characters and dispatch (rethink?)
- ' quoting
- ` and , quasiquoting
- : keywords, symbol modules
- \ escape next char
- ; comments


non-alphanumeric characters used in identifiers

- ! as a suffix indicates mutation (it's like we're yelling!)
- @ by itself is the universal accessor
- & by itself denotes rest arguments
- *, +, /, =, <, >, _, - (normal identifiers)


Characters discarded from CL:

- || for multi-char escapes
- . for dotted lists (what a dumb useless thing)


Characters reserved for future extensions

- ~, ^, %, and ?


*Ideas*

- Perhaps programmers should be encouraged to make use of $-args in their own
  macros in order to further promote consistency in the language, for instance
  to automatically create gensyms in macros.
- Maybe drop the ! convention-- since global variables are immutable by default,
  it is less crucial to keep track of state changes. Maybe not, though, as
  constant globals can still contain mutable data structures (we'll think about
  that though-- possibly add an immutable flag to instances? (would have to make
  lists, dicts immutable by default))
- It would be cool if we could drop the # syntax altogether-- presently all it
  does is read in characters and alternative-radix numbers (could be done with
  0x00 syntax). Perhaps we could do this by taking the Javascript approach
  (strings of length 1 are single characters)
- I also like single quoting for string syntax, but I think it's important to
  lisp that we leave quoting characters alone. It's not such a hardship to use
  double quotes-- the idiots using C and Java have been doing it for ages (smart
  people have to do it too).


* Versions

** Version conventions

We will use the convention three number (major.minor.patch) release numbering.

There are special rules for major version 0, but in general we will

- increment the patch number for substantial bug fixes, optimizations, and minor
  interface improvements not related to the core language or the standard
  library (i.e. changes to the highlighting and the emacs mode)
- increment the minor version number for any compatibility breaking changes to
  the standard library, the addition of new library features, minor language
  changes, and additions to the language that do not break existing code (except
  for possibly introducing name collisions). Also increment it for changes to
  the tools and platform that don't break old interfaces
- increment the major version number for substantial changes or additions to the
  core language, platform, and tooling. Example: when we ditch Common Lisp and
  move on to our own custom vm, this will be a major version change.

Patch increments will happen on an as needed basis. I intend to test fn by
writing a lot of code in it. I'll fix bugs as I go and bump the patch number
when I feel like I'm at a logical place to do so. Don't expect to see a ton of
these early on. Minor and major version releases will have milestone lists, and
I will only increment the version number after reaching all the goals.

Since we don't expect to have a stable language or standard library for some
time, we will change the rules for the version 0 release series, with the goal
of having a stable language, library, and tools by the time we hit 1.0.


** Version 0.0.0 Milestones

   The goal for version 0.0.0 is to have the core language fully implemented
   except for symbols and modules. Our milestones are

   - 90% implementation of data structures (defdata) and protocols (defimpl,
     defproto). We'll be missing the generalized deftype, and we'll be missing
     more sophisticated options
   - emacs major mode with mostly-correct indentation and syntax highlighting
   - all core special operators implemented: def, def*, defdata, defimpl,
     defmacro, defn, defproto, defvar, @, and, case, cond, do, if, fn, let, new,
     set!
   - case sensitive reader
   - fn package that exposes all language forms. I should be able to do
     (in-package :fn) and write (approximately) fn code.
   - making # a normal character


** Version 0.1 Milestones

   For version 0.1, we want to have the core language and tooling fully
   implemented. If we do it right, then from this version all the way up to
   version 1.0, the only substantial changes will be in module system and
   standard library.

   - FN-READ, FN-EVAL, and FN-PRINT functions in the CL-FN package that let
     Common Lisp code embed fn
   - signal system for error handling and control flow
   - more general type definition
   - stable core language syntax, meaning we have to address quasiquoting, the
     colon, and the dot
   - differentiation of the empty list and false
   - emacs command to send fn code to a SLIME repl
   - change how function application works
   - add the Callable interface
   - decide on a standard library naming convention
   - add the Sequence interface and libraries
   - implementation of input/output streams
   - automatic type checks via type annotations


   *Notable Missing Features*

   - module system
   - doc strings and help function
   - stack traces/debugging features
   - bit vectors


** Version 1.0 Milestones

   Version 1.0 will be a usable programming language with actual tooling and a
   standard library that lets it do pretty much anything you'd want to do in a
   UNIX environment. At this point, it will still all be Common Lisp under the
   hood, but that will be abstracted away to being a simple implementation
   detail. After version 1.0, we'll flesh out the standard library a bit, but
   the next big milestone will be ditching Common Lisp entirely in favor of C++
   and LLVM.

   Once I reach the first release candidate, I'm going to take a break and
   develop a substantial amount of code in fn. My first project will be a VM
   orchestrator. During this time, I'll be adjusting language features, fixing
   bugs, and extending the standard library as needed.

   - I will have written a lot of code in fn and determined that it is useful
   - the core language will be stable
   - documentation functions work
   - foreign function interface
   - module system including library path, multi-file module declaration,
     submodules, imports and qualified imports, file imports, and reloading
   - standard library includes threading, filesystem, file I/O, IPC and network
     sockets, system shell commands, subprocesses, command line arguments,
     and environment variables (all the usual UNIX stuff)
   - consistent error handling interfaces across the entire standard library
   - emacs major mode has its own shell
   - emacs mode can collapse code forms (particularly function options/doc
     strings)
   - immutable reimplementation of dicts
   - defdata has options and knows how to use them (i.e. mutable, immutable)
   - debugging including programmatically-accessible stack traces and
     breakpoints, plus global debug options
   - different optimization levels (i.e. disable type checks)


   *Notable Missing Features*

   - port implementation from Common Lisp to C++
   - compiler via LLVM
   - scientific and symbolic computing in the standard library
   - regex in the standard library
   - package/module manager
   - web server

