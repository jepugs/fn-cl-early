* Introduction

fn is a programming language in the Lisp family. It will feature a robust and streamlined object
system, an intuitive module-based approach to code organization, powerful metaprogramming
facilities, and a variety of quality of life features that aid in writing especially concise code
without sacrificing clarity.

** fn compared to other dialects of Lisp

Compared to most dialects of Lisp, fn has a small number of special forms, several new syntactic
conveniences, and a strong focus on its native object system. The object system strives to avoid
several of CLOS, namely its feeling tacked-on to the rest of the language and being rather verbose.

In addition, fn code is homoiconic like Common Lisp, allowing writing of macros in the traditional
Lisp way, which I greatly prefer to the hygienic macros and templates of e.g. Racket or Scheme.


** Implementation notes

- Everything is implemented in Common Lisp. The only supported implementation is SBCL. No particular
  effort is made to maintain ANSI compliance, although most of the code is ANSI anyway.
- This code is only tested on a handful of my personal computers, all of which run Arch Linux.
- I am currently in the process of rewriting fn. The previous version, which was nearly a feature
  complete version 0, was built as a layer on top of Common Lisp, using the Common Lisp reader and
  macros to implement almost all of its features. This new version will be a proper interpreter.


** Inspirations/Credit

fn's design was strongly inspired by Clojure, Python, Common Lisp, and Haskell. All four of those
are great programming languages. Honestly, if I could get a full version of Clojure that didn't need
the JVM or the CLR, I might not have bothered making a new programming language, although I really
don't care for pure functionality as much as Rich Hickey. In that respect I prefer Common Lisp. When
you get down to it, Common Lisp can be massaged into a very good language and development
environment using FOSS tools and libraries such as Quicklisp, Alexandria, and Emacs+SLIME. Common
Lisp can be further customized to the extent that even built-in special forms and syntax can be
overwritten, which is what I used to prototype early versions of fn. However, I have two serious
problems with Common Lisp. Firstly, it is too much work to configure a Common Lisp environment
compared to, say, Python or Haskell, which are essentially ready to go out of the box. While this
can be overcome by patience, a more significant problem is that since Common Lisp is built out of
so many different pieces, it feels very inconsistent in a way that is often jarring. Thus, I set out
to build a programming language just, for myself, that took the good parts of Common Lisp and added
some modern features.


* New parameter lists

  The goal with FN's new parameter lists is to create simpler, terser syntax while maintaining
  important features, namely keyword arguments, optional arguments, and variadic arguments. To
  achieve this. To achieve this, we use Scheme-style optional argument syntax. Since keywords as
  such do not exist in FN, we use quoted symbols to denote keyword arguments. Other than this
  change, calling a function with keyword arguments works identically to how it works in Common
  Lisp. On the parameter list side of things, keyword arguments are denoted identically to normal
  positional or optional arguments, except that the symbol name is quoted. Thus it is possible to
  make required keyword arguments.

  Variadic arguments can be accepted using the ampersand symbol (&) followed by a variable name for
  the list of trailing arguments.

  #+BEGIN_SRC fn
  (def (func positional-arg (optional-arg "init") ('keyword-arg "key-init"))
    (function-body))
  #+END_SRC

  And here are some translations from Common Lisp:

  #+BEGIN_SRC fn
  (defun operator (operand0 &rest operands) ...)
  ;; => (in FN)
  (def (operator operand0 & operands) ...)

  (defun log (x &optional (base 10)) ...)
  ;; => lists replace &optional
  (def (log x (base 10)) ...)

  (defun sort (seq &key (test #'< test-p) (ascending t)) ...)
  ;; => keyword arguments replace &key
  (def (sort seq ('test <) ('ascending t)) ...)
  #+END_SRC

  #+BEGIN_SRC fn
  ;; define a function requiring a keyword argument
  (def (func 'req-key ('opt-key "default")) 
    (function-body))

  (func) ;=> error (needs req-key)
  (func 'req-key 6) ;=> okay (opt-key = "default")
  (func 'opt-key 9) ;=> error (needs req-key)
  (func 'req-key 6 'opt-key 9) ;=> okay
  #+END_SRC


* Modules and Name resolution

** Definition order

In fn, loading source files behaves as is they are evaluated one expression at a time from beginning
to end. Function and variable lookups may be performed at runtime, so a function may use a variable
or another function whose definition appears later in the file.

The same rules generally apply to macros, but with some gotchas. Macros may be defined in the same
file they are used in, but must be appear (lexically) before any uses. If a macro uses a function to
create its expansion, then that function must be defined before the macro is first expanded (duh)


** Modules

Right now, modules have a 1-to-1 correlation with fn source files. To import a file, you use import
with a symbol corresponding to the file name, without any extension.

#+BEGIN_SRC fn
;; imports from file "x.fn" and binds the module as x
(import x)
;; imports from file "x.fn" and binds the module as y
(import x 'as y)
;; imports from file "x.fn" and binds all variables locally
(import x 'as _)
#+END_SRC

Modules are first class objects and their variables may be accessed using ~get~ or dot syntax.

#+BEGIN_SRC fn
;; file my-module.fn
(def my-var 26)

;; file example-a.fn
(import my-module)
my-module.my-var ;=> 26

;; file example-b.fn
(import my-module 'as mod)
mod.my-var ;=> 26

;; file example-c.fn
(import my-module 'as _)
my-var ;=> 26
#+END_SRC


*** Accessing modules without imports

The function ~(find-module sym)~ can be used to search for modules at runtime (the argument ~sym~ is
evaluated). Additionally, the syntax ~#.sym~ (eqv. to ~(get # 'sym~)) is available as a shorthand for
module lookups.


*** Implementation note: modules, macros, and dynamic vars

In Common Lisp, importing a macro means importing a symbol from another package. E.g. I import ~LOOP~
from ~CL~ and now every time I type ~loop~ it gets silently converted to ~CL:LOOP~. This allows a
one-to-one correspondence between macros and the symbols that represent them. At evaluation time, we
are guaranteed that the operator for a macro expression will always be a symbol, and its just a
matter of looking in that symbol's macro binding slot. In ~fn~, we no longer have the guarantee that
the operator is a symbol, and we have first-class module objects instead of packages, so we need to
take a more sophisticated approach.

The interpreter will internally maintain a list of which symbols (if any) are bound to modules.
Then, to do macro expansion on a list, we perform two checks: first, whether it's a symbol bound to
a macro in the current module (duh). If not, we check next whether the operator is a ~get~ expression.
If it is, and its first argument is a symbol referencing an imported module, then we can check that
module for macro bindings as well. This allows painless use of macros from other modules.


*** Future extension: ~__modules.fn~

In the future, a file named ~__modules.fn~ may be added to a source directory in order to define
modules that don't correspond directly to files and to modify the search path on a per-project
basis. In addition, it will be possible to automatically define wrapper modules that import all
their variables from submodules in order to create cleaner interfaces.


** Dynamic variables

In fn, dynamic variables may be created using ~defvar*~. In keeping with lisp tradition, we
recommend naming dynamic variables with earmuffs. (No ~def*~ form is included, because all dynamic
variables need to be resolved, well, dynamically, so they might as well be mutable).

#+BEGIN_SRC fn
(defvar* *name* initial-value)
#+END_SRC

This declares ~*name*~ to be a dynamic variable. Dynamic variables may be rebound with ~let~.

#+BEGIN_SRC fn
(defvar *special-x* 27)

(def (get-value) *special-x*)

(get-value) ;=> 27
(let (*special-x* 420)
  (get-value) ;=> 420
  )
(get-value) ;=>27
#+END_SRC

IMPORTANT NOTE:* Unlike in other dialects of lisp, special variables must be declared before they
are treated as special. Uses prior to that point will be treated as normal lexical variables.
Example:

#+BEGIN_SRC fn
(def (call-with-square-0 fun x)
  (let (sq (* x x))
    (fun sq)))

(defvar* sq 16)

(def (call-with-square-1 fun x)
  (let (sq (* x x))
    (fun sq)))

(def (get-sq _) sq)

;; call-with-square-0 treats sq as a normal lexical variable because it was defined before sq was 
;; declared dynamic.
(call-with-square-0 get-sq 6) ;=>16

;; call-with-square-1 treats sq as a dynamic variable
(call-with-square-0 get-sq 6) ;=>36

#+END_SRC


* Functions

There are two special operators that create functions: ~fn~ and ~dollar-fn~. The latter is usually
written using dollar-sign syntax. The expression ~$(function-body)~ expands to ~(dollar-fn
(function-body))~.

#+BEGIN_SRC fn
  ;; syntax for fn is
  (fn (<parameters>) <body>)

  ;; there are three kinds of parameters recognized by fn: positional, keyword, and variadic.
  ;; Positional params are denoted by plain symbols and keyword params by quoted symbols. Variadic
  ;; parameters are defined by using the special symbol & followed by a symbol indicating the name of
  ;; the variable.

  ;; function that takes two positional arguments and sums their reciprocals
  (def sum-inv 
    (fn (x y)
      (+ (/ 1 x) (/ 1 y))))
  (sum-inv 0.5 0.2) ;; => 7

  ;; function that takes one positional argument and two keyword arguments. This function will 
  ;; apply the function if-num if v is a number, otherwise it will apply 'otherwise.
  (def apply-if-num
    (fn (v 'if-num 'if-not)
      (if (num? v)
          (if-num v)
          (if-not v))))
  ;; to call functions with keyword arguments, simply put the quoted symbols in the argument list
  (apply-if-num "hello" 'if-num String 'if-not println) ;; prints "hello"
  ;; keyword arguments may be provided in any order
  (apply-if-num 2 'if-not println 'if-num String) ;; => "2"

  ;; keyword and positional parameters can be made optional by putting them in parentheses followed 
  ;; by a default expression. Required parameters may not succeed optional ones.
  (def increment (num (by 1))
    (+ num by))
  (increment 17) ; => 18 (uses default value for by)
  (increment 17 2); => 18

  ;; variadic arguments must come last in an argument list.
  (def string-sum (& numbers)
    (String (apply + numbers)))

#+END_SRC

*** Wildcard parameters

Positional parameters using the wildcard symbol "_" are treated specially. Such parameters do not
cause any variables to be bound in the function body, i.e. the argument in the corresponding
position is ignored. These may also be used as optional arguments, although a dummy default value
must still be provided, e.g. ~(_ null)~


*** Variadic arguments and keywords

When a function accepts both keywords and variadic arguments, all the variadic arguments must be
alternating symbol and value pairs, just like normal keyword arguments. This behavior is very
similar to the behavior of combining ~&REST~ and ~&ALLOW-OTHER-KEYS~ in Common Lisp. The one difference
is that the property list bound to the variadic argument will not contain any of the explicitly
specified keyword parameters. That is:

#+BEGIN_SRC fn
(def (fun 'key1 & other-keys)
  other-keys)

;; other-keys will not contain the value for 'key1
(fun 'key1 4 'key2 6 'key3 8)
;; => ('key2 6 'key3 8)

#+END_SRC

Functions which accept both variadic arguments and keywords have argument checking done to make that
the keyword arguments form a plist. To get argument checking without having any explicit keyword
arguments, include "'_" (quote underscore) in the parameter list.

#+BEGIN_SRC fn
;; this function accepts any arguments
(def (fun1 & args)
  args)
;; so this is fine
(fun1 'key 2 3.14159 "hello" 'key2)

;; this function only accepts arguments that form a proper plist
(def (fun2 '_ & args)
  args)
;; this is an error
(fun2 'key 2 3.14159 "hello" 'key2)
;; but this is fine
(fun2 'key 2 'key2 "hello")

#+END_SRC


* Type System

** Type definition

New types can be defined using the ~deftype~ special form. Types are first-class objects and invoking
~deftype~ causes creation of a global type object of the specified name. However, there is no way to
create new type objects other than by using ~deftype~, i.e. there are no non-global types.

The *fields* of an object are the key-value pairs it contains. They can be accessed with ~field-value~
or ~@~. Objects may be instantiated by calling the type as

By convention, type and protocol names begin with capital letters.

#+BEGIN_SRC fn
;; Type and protocol creation
(deftype (Type-Name args...) options...)
;; at this time no options are supported

;; to invoke the constructor, use the type as a function
(Type-Name args...)

;; Access fields directly
(field-value obj 'field)
(set (field-value obj 'field) new-value)

;; Access fields via the generic accessors
(@ obj 'field)
(set (@ obj 'field) new-value)
;; or, equivalently,
obj.field
(set obj.field new-value)
;; this dot notation is preferred wherever possible

#+END_SRC

*** Future features

Options should allow customization of the object's internal representation, constructor, and fields.
E.g. fields may be marked mutable or have type restrictions applied.


** Polymorphism via Methods

fn provides polymorphism in the form of methods. fn's methods support multiple dispatch (i.e. they
are multimethods). The syntax is demonstrated below.

#+BEGIN_SRC fn
;; To define a multimethod, you must specify its name, a list of one or more dispatch parameters,
;; and a parameter list containing all the dispatch parameters.

(defmethod ((<name> <dispatch-params>) <params>))

;; Methods are implemented using def. Syntax is very similar to function definition except that
;; the name of the method and the dispatch types must also be specified.
(def ((<name> <dispatch-types>) <params>)
  <implementation-body>)

;;; EXAMPLE: the call method (used to treat arbitrary objects as functions)
;; call does dispatch on the argument obj
(defmethod ((call obj) obj & args))

;; implementation of call on classes
(def ((call Class) class & args)
  (apply class.constructor args))

;;; EXAMPLE: the mul method used to extend multiplication.
;; mul does multiple dispatch on the arguments l and r
(defmethod ((mul l r) l r))

;; implement methods using def. Parameter names may be changed.
(def ((mul Num String) ct str)
  (loop (i res) (ct "")
    (if (= i 0)
        res
        (recur (- i 1)
               (append res str)))))

(def ((mul String Num) str ct)
  ;; simply flip the arguments 
  (mul ct str))

;; potential alternative syntax?
(set (@ mul [String Num]) function)

#+END_SRC

*** Implementation

Dispatch is done using hash trees. The depth of the tree is determined by the number of dispatch
parameters. One layer is added for each dispatch parameter.

In the future, dispatch behavior will likely become more complicated, as features like or, satisfies,
and wildcard types are added.


** Built-in types

The following types are built into fn.

*Atomic types*
- Symbol :: symbol
- Bool :: boolean denoted ~true~ or ~false~
- Null :: unassigned value denoted ~null~
- Num :: 64-bit floating-point number

*Structure types*
- List :: singley-linked list
- Table :: general-purpose hash table
- Array :: generic one-dimensional vector
- Type :: the type of types
- String :: character string

Foreign data structures and bit array types will be added in the future.


** Misc Type Functions

Use ~(type-of obj)~ to get the type of an object. This returns a symbol equal to the name of the class
of obj. I.e., ~(type-of obj)~ is equivalent to ~(get (class-of obj) 'name)~.

The slots of an object can be accessed using ~get~.


* Version 0 Spec

If anyone other than me ever tries to read this, I'm sorry. This is a "complete" specification of
version 0 of the fn programming language (i.e. complete enough for me, the language designer, to
remember the decisions I've made so far).

** Core language cheat sheet

This sample code contains every special form in fn.

#+BEGIN_SRC fn
;; variable definition
(def var value)
(def (fun param*) body*)
(def ((method dispatch-types) param*) body*)
(defvar var value)

;; type system
(defclass (Type arg*))
(defmethod ((method-name type-var*) param*))

;; get/set
(get obj field)
(@ obj key)
(set place value)

;; function creation
(fn (x) (+ x 2))
$(+ $ 2)
(dollar-fn (+ $ 2))

;; control flow
(apply fun lst)
(do expr*)
(let (var1 val1
      var2 val2
      (fun-var arg*)
        (body))
  expr*)
(if condition
    then-expr
    else-expr)
(cond
  condition1 
    expr1
  condition2 
    expr2)
(case obj
  pattern1
    expr1
  pattern2
    expr2)

;; code as data/macros
(defmacro (name arg*)
  macro-body)
'x
(quote x)
`(a b ,(+ 2 4))
(quasiquote (a b (unquote (+ 2 4))))

#+END_SRC


** Flow control

- cond
- do
- if
- let

*if* works as it always does and *do* works like ~PROGN~ does in Common Lisp or ~begin~ in Scheme.

*cond* has its syntax changed so omit the second level of parentheses. Instead, it takes an
alternating series of tests and results, and automatically groups them into pairs.

#+BEGIN_SRC fn
  ;; syntax
  (cond
    test0
      result0
    test1
      result1)

  ;; example. returns "fizz" if x is a multiple of 3, "buzz" if it's a multiple of 5, "fizzbuzz" if
  ;; it's both, and x as a string if it's neither.
  (defn foo (x)
    (cond
      (= (mod x 15) 0) "fizzbuzz"
      (= (mod x 5) 0) "buzz"
      (= (mod x 3) 0) "fizz")
      (true (String x)))
#+END_SRC


~let~ has been modified in a similar way, doing away with the second layer of parentheses in the
binding specs

#+BEGIN_SRC fn
  (let (a 2
        b 3
        c 4)
    (+ a b c))
  ;; => 9

  ;; let behaves like scheme's letrec
  (defn reverse-map (f lst)
    (let (iter
           (fn (acc src)
             (if src
                 (iter (cons (f src.hd) acc)
                       src.tl)
                 acc)))
      (iter [] lst)))
                   
#+END_SRC


** Function creation

- fn
- $ (dollar sign syntax)


** Type System 

Version 0 will implement the complete type system as described in Type System at the top level of
this document.


** Generic accessors

*** @

The generic getter is ~@~. It gets values from objects given some key.

#+BEGIN_SRC fn
;; function signature for @
(defn @ (object key0 & keys)
  ...)
#+END_SRC fn

When multiple keys are passed as arguments, each successive key is used to access the value from the
previous key. E.g. ~(@ obj key1 key2)~ is equivalent to ~(@ (@ obj key1) key2)~.

The default behavior for ~@~ on new types is to act like ~slot-value~.


*** dot notation

The dot (.) is used as a shorthand for ~@~ when the object is a variable and the key is a symbol. For
example, the following two expressions are equivalent:

#+BEGIN_SRC fn
;; 1.
object.slot
;; 2.
(@ object 'slot)
#+END_SRC

In fact, the reader converts the former expression to the latter before evaluation.

Multiple dots can also be used to supply more keys:

#+BEGIN_SRC fn
object.slot1.slot2
;; is equivalent to
(@ object 'slot1 'slot2)
#+END_SRC


*** Default Callable (Potential alternative to dot notation)

The dot is an attractive syntax because it allows tree descent with the addition of only one
character of syntax per depth. An alternative syntax would be achieved by giving all objects a
default Callable protocol implementation that invokes ~@~ on the object with the specified arguments.
E.g:

;; this
object.key.key2.key3
;; would be replaced by this
(object 'key1 'key2 'key3)

I guess we could also do both, but that seems like overkill. I'm leaning towards keeping dot notation.


*** set

The generic setter is ~set~.

#+BEGIN_SRC fn
(defmacro set (place value)
  ...)

;; define a mutable variable
(defvar x 27)
x
;;=> 27
(set x 32)
x
;;=> 32

;; mutate the field of an object
(set obj.slot 'funk)
;; equivalent w/o dot notation
(set (@ obj slot) 'funk)
#+END_SRC

The place can be a variable name, in which case the variable is mutated. It may also be an ~@~ form,
which will invoke the generic


** Definition

These are all the variable definition facilities in fn

#+BEGIN_SRC fn
;; define a constant variable
(def VAR VALUE "Doc string")
;; define a mutable variable
(defvar VAR VALUE "Doc string")
;; define a function
(defn VAR (ARG-LIST...)
  "Doc string"
  (options FUNCTION-OPTIONS...)
  FUNCTION-BODY) 

#+END_SRC


** Macros

#+BEGIN_SRC fn
;; define a macro
(defmacro NAME (ARG-LIST...)
  "Doc string"
  MACRO-BODY)
#+END_SRC

Macros work in the usual lisp way, and they are unsanitary. Macro functions may return function
objects as part of their outputs. This is encouraged as a way to prevent lexical variable
definitions from colliding with global module or function names.

*Note:* In the future, some facility e.g. a ~global~ special form may be introduced which allows global
variables to be accessed from macros without needing to include them as literals. Such a form would
possibly return a pointer object that unambiguous denoted the variable being referenced.


** Pattern matching

Will not be implemented with the first version


** Standard Library

- @
- +,-,*,/
- add,sub,mul,div (corresp. to Add, Sub, Mul, Div protocols)
- call (w/ Callable protocol)
- get (w/ Get protocol, used by @)
- print
- random
- set (macro)
- slot-value
- type-of


** Complete list of special operators

- apply
- case
- cond
- def
- defimpl
- defmacro
- defn
- defproto
- defvar
- do
- fn
- let
- quote
- quasiquote
- unquote


** Syntax

Syntax is standard lisp parenthesized prefix notation. The following are all the special syntax
characters:

$()[]{}\;"',.

all other non-whitespace characters are symbol constituents, that is, they are parsed as atoms, i.e.
as symbols or numbers.


*** Delimiters

In typical lisp fashion, () are the delimiters denoting lists. In addition, [] and {} are matched
delimiters for reading lists and dicts. In fact, they are converted by the reader.

[a b c] -> (List a b c),
and
{:a 0 :b 1} -> (Dict :a 0 :b 1)

Also, "" reads UTF-8 strings. It uses C/C++ escape sequences because those are better than the lisp
ones and support Unicodes. Get over it.


*** Comments

There are no multi-line comments in fn. Only line-end comments, started by semicolons, are
supported.


*** Dollar sign

See function creation.


*** Quotation

Normal quote works as it usually does in Lisp. Quasiquote works the same but lacks a destructive
splice.


*** Escaping

Escaping is when a backslash (/) character is placed in front of another character, thereby turning it
into a symbol constituent.. Any character can be escaped in any context except for within a string, (where string
escaping rules apply instead).


*** Dot notation

See Generic Accessors


* Misc Notes and Ideas

** Important idea: global pointers

I think it would be very useful to introduce a "pointer" data type (a better name might be GUID,
place, or address) which is simply an unambiguous reference to some global variable (possibly also
local?). GUID syntax could start with #G (or something) and would be very much analogous to symbols
in Common Lisp, in that GUIDs, like CL's symbols, would be standalone places to store objects. This
also allows an elegant alternative to gensyms, i.e. randomly-generated, disposable places.


** Future Features

Once I've implemented everything up to version 0, I'm going to get to work on a module system as
well as a way to sanitize macros where necessary (probably via some sort of GUID for global
variables). That will be version 0.1. From there, the next steps will be to add multithreading and
FFI and to otherwise flesh out the standard library, which eventually will lead me to version 0.2
(and possibly 0.3 depending on how I break up the work). I will not increment to version 1.0 until
the interpreter is rewritten in C++. Further goals include implementing JIT compilation using LLVM,
adding a scientific computing/linear algebra library, and adding networking and IPC modules.



** Version 0 lexer tokens

(delimiters)
left-paren, right-paren, left-bracket, right-bracket, left-brace, right-brace

(unary operators)
dollar-sign, quote, backtick, comma, comma-splice

(binary operator)
dot

(literals)
number, string, symbol

comments

eof


** Version 0 grammar

#+BEGIN_SRC haskell
program -> expr* EOF
expr    -> constant
         | compound
         | unary
         | dot

constant -> STRING
          | NUMBER

compound -> paren
          | bracket
          | brace
paren    -> "(" expr* ")"
bracket  -> "[" expr* "]"
brace    -> "{" expr* "}"

unary      -> quote
            | quasiquote
            | unquote
            | unquote-splicing
            | dollar
quot       -> "'" expr
quasiquot  -> "`" expr
unquot     -> "," expr
unquot-splice -> ",@" expr
dollar     -> "$(" expr* ")"
            | "$[" expr* "]"
            | "${" expr* "}"
            | "$" quasiquote

dot -> SYMBOL "." SYMBOL
     | dot "." SYMBOL
#+END_SRC

#+BEGIN_SRC common-lisp
  (defun token-is? (tok kind)
    (eq (token-kind tok) kind))

  (make-parser
   ;; first form is grammar
   ((program -> (* expr) @eof)
    (expr -> constant / group / unary / dollar / dot)

    (constant -> @string / @number)

    (group -> paren / bracket / brace)
    (paren -> @left-paren (* expr) @right-paren)
    (bracket -> @left-bracket (* expr) @right-bracket)
    (brace -> @left-brace (* expr) @right-brace)

    (unary -> quot / quasiquot / unquot / unquot-splicing)
    (quot -> @quot expr)
    (quasiquot -> @backtick expr)
    (unquot -> @comma expr)
    (unquot-splice -> @comma-splice expr)

    (dollar -> @dollar-paren (* expr) @right-paren
            / @dollar-bracket (* expr) @right-bracket
            / @dollar-brace (* expr) @right-brace
            / @dollar-backtick expr)

    (dot -> var / dot @dot var)
    (var -> @symbol))

   ;; remaining forms are callbacks for nonterminals. Whenever a reduce is performed, the callback
   ;; corresponding to the generated nonterminal is invoked with a single argument, a list of the
   ;; POBJs used to make this pattern.
   (constant #'constant-fun)
   (dot #'dot-fun)
   (var #'var-fun)
   )

#+END_SRC


** Bytecode version 0

All instructions are 1 byte long. The first machine will be a register machine, because it's going
to be a register machine eventually anyway.


** Registers and calling conventions

Each general-purpose register has two parts: an 8-bit tag and a 64-bit value. The tag indicates the
type of the data. Each thread has 256 general-purpose registers, denoted by the notation R(xx) where
xx is a two-digit hexadecimal number in the range 00-FF, e.g. R(5E), R(C7), and R(19).

At any given time, a certain set of registers are considered active.


** Load instructions

These operators load a value at the top of the stack.

- LD_NUM reg float64    :: floating-point number literal
- LD_STR reg ptr64      :: constant string
- LD_LIST reg ptr64     :: non-empty list
- LD_EMPTY reg ptr64    :: empty list
- LD_TRUE reg           :: true
- LD_FALSE reg          :: false
- LD_NULL reg           :: null
- LD_SYMB reg ptr64     :: symbol
- LD_OBJ reg ptr64      :: load another type of object
- LD_VAR reg ptr64      :: global variable reference (64-bit pointer argument)
- LD_ADDR reg ptr64     :: an address. Could be used for either bytecode or system memory

- LD_REG reg reg        :: load a register value. Args in (dest,source) order

Each of the above also sets the tag bits of the associated register to a unique value based on the
instruction in question, with LD_VAR manually reading the tag of the variable before assigning it
and a pointer to the object to the specified register.


*** Future load instructions

Eventually, it would be cool to add tags for arbitrary-precision floats and integers.


** Object representation

Objects are always passed around as pointers. Variables and registers are tagged to keep track of
object types. Because values are always returned in a register, tags are also preserved.

In addition, the first


** Calling and Stack manipulation

This version of ~fn~ is "stackless", meaning that stack frames are allocated on the heap. The
registers are primarily used for two things: some registers (32?) are reserved for passing
arguments, while the rest are used to hold the results of temporary evaluations.

- CLOSE reg :: create a new closure. This just 


** Alternative: Virtual Memory and Built-in tags

I don't think I'll do this because keeping full 64-bit pointers would make foreign code interop and
low-level code writing much easier.

Suppose we limit ourselves to 56-bit pointers, which is still more than enough memory. Then, we have
8 bytes of the string which we can use as a type tag. We can use a variable-length tagging scheme to
get 62-bit fixed-width integers and if we pick tag 00 (binary) for those, we can use CPU native
integer arithmetic operations. It would also be possible to truncate 64-bit floating point numbers
to 62-bit precision by dropping the two rightmost digit, allowing use of x87 hardware and making
passing around of numbers, etc, much more efficient. A downside of this approach is that it would
give us less than the maximum 256 possible type tags that exist right now.

** Alt. Defn syntax

#+BEGIN_SRC fn
(defn x "Optional doc-string"
  (arg-pattern-1)
    fn-body-1
  (arg-pattern-2)
    fn-body-2
  ...)

i.e.

(defn factorial
  (0) 1
  (n) (* n (factorial (- n 1))))

(defn map
  ([]) )

;; alternative: allow multiple defn's per file
(defn factorial (0) 1)
(defn factorial (n) (* n (factorial (- n 1)))


#+END_SRC


* Tree Walker

The first interpreter is a tree walker. The reason for this is that it is far easier to make
extensions and changes to this sort of interpreter than to a VM based one.


