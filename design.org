* Introduction

fn is a programming language in the Lisp family. It will feature a robust and streamlined object
system, an intuitive module-based approach to code organization, powerful metaprogramming
facilities, and a variety of quality of life features that aid in writing especially concise code
without sacrificing clarity.


** fn compared to other dialects of Lisp

Compared to most dialects of Lisp, fn has a small number of special forms, several new syntactic
conveniences, and a strong focus on its native object system. The object system strives to avoid
several of CLOS, namely its feeling tacked-on to the rest of the language and being rather verbose.

In addition, fn code is homoiconic like Common Lisp, allowing writing of macros in the traditional
Lisp way, which I greatly prefer to the hygienic macros and templates of e.g. Racket or Scheme.


** Implementation notes

- Everything is implemented in Common Lisp. The only supported implementation is SBCL. No particular
  effort is made to maintain ANSI compliance, although most of the code is ANSI anyway.
- This code is only tested on a handful of my personal computers, all of which run Arch Linux.
- I am currently in the process of rewriting fn. The previous version, which was nearly a feature
  complete version 0, was built as a layer on top of Common Lisp, using the Common Lisp reader and
  macros to implement almost all of its features. This new version will be a proper interpreter.


** Inspirations/Credit

fn's design was strongly inspired by Clojure, Python, Common Lisp, and Haskell. All four of those
are great programming languages. Honestly, if I could get a full version of Clojure that didn't need
the JVM or the CLR, I might not have bothered making a new programming language, although I really
don't care for pure functionality as much as Rich Hickey. In that respect I prefer Common Lisp. When
you get down to it, Common Lisp can be massaged into a very good language and development
environment using FOSS tools and libraries such as Quicklisp, Alexandria, and Emacs+SLIME. Common
Lisp can be further customized to the extent that even built-in special forms and syntax can be
overwritten, which is what I used to prototype early versions of fn. However, I have two serious
problems with Common Lisp. Firstly, it is too much work to configure a Common Lisp environment
compared to, say, Python or Haskell, which are essentially ready to go out of the box. While this
can be overcome by patience, a more significant problem is that since Common Lisp is built out of
so many different pieces, it feels very inconsistent in a way that is often jarring. Thus, I set out
to build a programming language just, for myself, that took the good parts of Common Lisp and added
some modern features.


* New parameter lists

  The goal with FN's new parameter lists is to create simpler, terser syntax while maintaining
  important features, namely keyword arguments, optional arguments, and variadic arguments. To
  achieve this. To achieve this, we use Scheme-style optional argument syntax. Since keywords as
  such do not exist in FN, we use quoted symbols to denote keyword arguments. Other than this
  change, calling a function with keyword arguments works identically to how it works in Common
  Lisp. On the parameter list side of things, keyword arguments are denoted identically to normal
  positional or optional arguments, except that the symbol name is quoted. Thus it is possible to
  make required keyword arguments.

  Variadic arguments can be accepted using the ampersand symbol (&) followed by a variable name for
  the list of trailing arguments.

  #+BEGIN_SRC fn
  (defn func (positional-arg (optional-arg "init") ('keyword-arg "key-init"))
    (function-body))
  #+END_SRC

  And here are some translations from Common Lisp:

  #+BEGIN_SRC fn
  (defun operator (operand0 &rest operands) ...)
  ;; => (in FN)
  (defn operator (operand0 & operands) ...)

  (defun log (x &optional (base 10)) ...)
  ;; => lists replace &optional
  (defn log (x (base 10)) ...)

  (defun sort (seq &key (test #'< test-p) (ascending t)) ...)
  ;; => keyword arguments replace &key
  (defn sort (seq ('test #'<) ('ascending t)) ...)
  #+END_SRC

  #+BEGIN_SRC fn
  ;; define a function requiring a keyword argument
  (defn func ('req-key ('opt-key "default")) 
    (function-body))

  (func) ;=> error (needs req-key)
  (func 'req-key 6) ;=> okay (opt-key = "default")
  (func 'opt-key 9) ;=> error (needs req-key)
  (func 'req-key 6 'opt-key 9) ;=> okay
  #+END_SRC


* Type System 

** Object system

New types can be defined using the ~deftype~ special form. Types are first-class objects and invoking
~deftype~ causes creation of a global type object of the specified name. However, there is no way to
create new type objects other than by using ~deftype~, i.e. there are no non-global types.

The *internal slots* of an object are the key-value pairs it contains. They can be accessed with
~slot-value~. The *constructor* of a type is a function that creates new instances of a type. It is
usually generated automatically by ~deftype~, however it may be manually specified via the options.

#+BEGIN_SRC fn
;; Type and protocol creation
(deftype Type-Name (slots...) options...)
;; Instantiate an arbitrary object by manually assigning slot values
(instantiate TYPE SLOT-VALUES...)
;; to invoke the constructor, use the object as a Callable instance
(TYPE ARGS...)

;; Access slots directly
(slot-value OBJ SLOT)
(set (slot-value OBJ SLOT) NEW-VALUE)

;; Access slots via the generic accessors
(@ OBJ SLOT)
#+END_SRC


** Protocols and Implementation

A protocol is a group of functions whose behaviors are decided based upon the types of some of their
arguments, called dispatch arguments.

#+BEGIN_SRC fn
(defproto Proto-Name (types...)
  (function-name-1 arg-list options...)
  (function-name-2 arg-list options...))
(defimpl Proto-Name (types...)
  function-name-1 implementation-function-1
  function-name-2 implementation-function-2)

;; Example: the built-in Mul protocol
(defproto Mul (l r)
  (mul (l r) "Multiply two numbers"))

;; Example: Implementing multiplication on a custom 2D vector type
(deftype Vec2 (x y))

(defn vec2-scalar-mul (s v)
  "Multiply a vec2 by a scalar"
  (Vec2 (* s v.x) (* s v.y)))


;; define for all four scalar combinations
(defimpl Mul (Int Vec2)
  mul vec2-scalar-mul)
(defimpl Mul (Vec2 Int)
  mul $(vec2-scalar-mul $1 $0))
(defimpl Mul (Float Vec2)
  mul vec2-scalar-mul)
(defimpl Mul (Vec2 Float)
  mul $(vec2-scalar-mul $1 $0))

(* (Vec2 1.0 2.3) -2)
;;=> (Vec2 -2.0 -4.6)
(* 1.1 (Vec2 1.2 1.3))
;;=> (Vec2 1.32 1.43)

#+END_SRC


** Built-in types

The following types are built into fn.

*Atomic types*
- Symbol :: symbol
- Bool :: boolean True or False
- Null :: unassigned value 
- Int :: integer (not necessarily fixed int)
- Float :: floating point number
- String :: character string

*Structure types*
- List :: singley-linked list
- Dict :: general-purpose hash table
- Arr :: generic one-dimensional (for now) array
- Type :: the type of types

Foreign data structures and bit array types will be added in the future.


** Built-in Protocols

- Add :: used for the + operator
- Sub :: used for the - operator
- Mul :: used for the * operator
- Div :: used for the / operator
- Callable :: allows the type to be called like a function
- Get :: specifies behavior of @


** Misc Type Functions

Use ~(type-of OBJ)~ to get the type of an object.

The slots of an object can be accessed directly using ~(slot-value OBJ SLOT)~. Mutable slots can be
set using ~(set (slot-value ...) ...)~.


* Version 0 Spec

If anyone other than me ever tries to read this, I'm sorry. This is a "complete" specification of
version 0 of the fn programming language (i.e. complete enough for me, the language designer, to
remember the decisions I've made so far).

** Flow control

- cond
- do
- if
- let

*if* works as it always does and *do* works like ~PROGN~ does in Common Lisp or ~begin~ in Scheme.

*cond* has its syntax changed so omit the second level of parentheses. Instead, it takes an
alternating series of tests and results, and automatically groups them into pairs.

#+BEGIN_SRC fn
  ;; syntax
  (cond
    test0
      result0
    test1
      result1)

  ;; example. returns "fizz" if x is a multiple of 3, "buzz" if it's a multiple of 5, "fizzbuzz" if
  ;; it's both, and x as a string if it's neither.
  (defn foo (x)
    (cond
      (= (mod x 15) 0) "fizzbuzz"
      (= (mod x 5) 0) "buzz"
      (= (mod x 3) 0) "fizz")
      (True (String x)))
#+END_SRC


~let~ has been modified in a similar way, doing away with the second layer of parentheses in the
binding specs

#+BEGIN_SRC fn
  (let (a 2
        b 3
        c 4)
    (+ a b c))
  ;; => 9

  ;; let behaves like scheme's letrec
  (defn reverse-map (f lst)
    (let (iter
           (fn (acc src)
             (if src
                 (iter (cons (f src.hd) acc)
                       src.tl)
                 acc)))
      (iter [] lst)))
                   
#+END_SRC


** Function creation

- fn
- $ (dollar sign syntax)


** Type System 

Version 0 will implement the complete type system as described in Type System at the top level of
this document.


** Generic accessors

*** @

The generic getter is ~@~. It gets values from objects given some key.

#+BEGIN_SRC fn
;; function signature for @
(defn @ (object key0 & keys)
  ...)
#+END_SRC fn

When multiple keys are passed as arguments, each successive key is used to access the value from the
previous key. E.g. ~(@ obj key1 key2)~ is equivalent to ~(@ (@ obj key1) key2)~.

The default behavior for ~@~ on new types is to act like ~slot-value~.


*** dot notation (might remove)

The dot (.) is used as a shorthand for ~@~ when the object is a variable and the key is a symbol. For
example, the following two expressions are equivalent:

#+BEGIN_SRC fn
;; 1.
object.slot
;; 2.
(@ object 'slot)
#+END_SRC

In fact, the reader converts the former expression to the latter before evaluation.

Multiple dots can also be used to supply more keys:

#+BEGIN_SRC fn
object.slot1.slot2
;; is equivalent to
(@ object 'slot1 'slot2)
#+END_SRC


*** Default Callable (Potential alternative to dot notation)

The dot is an attractive syntax because it allows tree descent with the addition of only one
character of syntax per depth. An alternative syntax would be achieved by giving all objects a
default Callable protocol implementation that invokes ~@~ on the object with the specified arguments.
E.g:

;; this
object.key.key2.key3
;; would be replaced by this
(object 'key1 'key2 'key3)

I guess we could also do both, but that seems like overkill. I'm leaning towards keeping dot notation.


*** set

The generic setter is ~set~.

#+BEGIN_SRC fn
(defmacro set (place value)
  ...)

;; define a mutable variable
(defvar x 27)
x
;;=> 27
(set x 32)
x
;;=> 32

;; mutate the field of an object
(set obj.slot 'funk)
;; equivalent w/o dot notation
(set (@ obj slot) 'funk)
#+END_SRC

The place can be a variable name, in which case the variable is mutated. It may also be an ~@~ form,
which will invoke the generic


** Definition

These are all the variable definition facilities in fn

#+BEGIN_SRC fn
;; define a constant variable
(def VAR VALUE "Doc string")
;; define a mutable variable
(defvar VAR VALUE "Doc string")
;; define a function
(defn VAR (ARG-LIST...)
  "Doc string"
  (options FUNCTION-OPTIONS...)
  FUNCTION-BODY) 

#+END_SRC


** Macros

#+BEGIN_SRC fn
;; define a macro
(defmacro NAME (ARG-LIST...)
  "Doc string"
  MACRO-BODY)
#+END_SRC

Macros work in the usual lisp way, and they are unsanitary. Macro functions may return function
objects as part of their outputs. This is encouraged as a way to prevent lexical variable
definitions from colliding with global module or function names.

*Note:* In the future, some facility e.g. a ~global~ special form may be introduced which allows global
variables to be accessed from macros without needing to include them as literals. Such a form would
possibly return a pointer object that unambiguous denoted the variable being referenced.


** Pattern matching

Will not be implemented with the first version


** Standard Library

- @
- +,-,*,/
- add,sub,mul,div (corresp. to Add, Sub, Mul, Div protocols)
- call (w/ Callable protocol)
- get (w/ Get protocol, used by @)
- print
- random
- set (macro)
- slot-value
- type-of


** Complete list of special operators

- cond
- def
- defimpl
- defmacro
- defn
- defproto
- defvar
- do
- fn
- let
- quote
- quasiquote
- unquote


** Syntax

Syntax is standard lisp parenthesized prefix notation. The following are all the special syntax
characters:

$()[]{}\;"',.

all other non-whitespace characters are symbol constituents, that is, they are parsed as atoms, i.e.
as symbols or numbers.


*** Delimiters

In typical lisp fashion, () are the delimiters denoting lists. In addition, [] and {} are matched
delimiters for reading lists and dicts. In fact, they are converted by the reader.

[a b c] -> (List a b c),
and
{:a 0 :b 1} -> (Dict :a 0 :b 1)

Also, "" reads UTF-8 strings. It uses C/C++ escape sequences because those are better than the lisp
ones and support Unicodes. Get over it.


*** Comments

There are no multi-line comments in fn. Only line-end comments, started by semicolons, are
supported.


*** Dollar sign

See function creation.


*** Quotation

Normal quote works as it usually does in Lisp. Quasiquote works the same but lacks a destructive
splice.


*** Escaping

Escaping is when a backslash (/) character is placed in front of another character, thereby turning it
into a symbol constituent.. Any character can be escaped in any context except for within a string, (where string
escaping rules apply instead).


*** Dot notation

See Generic Accessors


* Misc Notes and Ideas

** Important idea: global pointers

I think it would be very useful to introduce a "pointer" data type (a better name might be GUID,
place, or address) which is simply an unambiguous reference to some global variable (possibly also
local?). GUID syntax could start with #G (or something) and would be very much analogous to symbols
in Common Lisp, in that GUIDs, like CL's symbols, would be standalone places to store objects. This
also allows an elegant alternative to gensyms, i.e. randomly-generated, disposable places.
