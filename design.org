* Introduction

fn is a programming language in the Lisp family. It will feature a robust and streamlined object
system, an intuitive module-based approach to code organization, powerful metaprogramming
facilities, and a variety of quality of life features that aid in writing especially concise code
without sacrificing clarity.


** fn compared to other dialects of Lisp

Compared to most dialects of Lisp, fn has a small number of special forms, several new syntactic
conveniences, and a strong focus on its native object system. The object system strives to avoid
several of CLOS, namely its feeling tacked-on to the rest of the language and being rather verbose.

In addition, fn code is homoiconic like Common Lisp, allowing writing of macros in the traditional
Lisp way, which I greatly prefer to the hygienic macros and templates of e.g. Racket or Scheme.

** Implementation notes

- Everything is implemented in Common Lisp. The only supported implementation is SBCL. No particular
  effort is made to maintain ANSI compliance, although most of the code is ANSI anyway.
- This code is only tested on a handful of my personal computers, all of which run Arch Linux.
- I am currently in the process of rewriting fn. The previous version, which was nearly a feature
  complete version 0, was built as a layer on top of Common Lisp, using the Common Lisp reader and
  macros to implement almost all of its features. This new version will be a proper interpreter.


** Inspirations/Credit

fn's design was strongly inspired by Clojure, Python, Common Lisp, and Haskell. All four of those
are great programming languages. Honestly, if I could get a full version of Clojure that didn't need
the JVM or the CLR, I might not have bothered making a new programming language, although I really
don't care for pure functionality as much as Rich Hickey. In that respect I prefer Common Lisp. When
you get down to it, Common Lisp can be massaged into a very good language and development
environment using FOSS tools and libraries such as Quicklisp, Alexandria, and Emacs+SLIME. Common
Lisp can be further customized to the extent that even built-in special forms and syntax can be
overwritten, which is what I used to prototype early versions of fn. However, I have two serious
problems with Common Lisp. Firstly, it is too much work to configure a Common Lisp environment
compared to, say, Python or Haskell, which are essentially ready to go out of the box. While this
can be overcome by patience, a more significant problem is that since Common Lisp is built out of
so many different pieces, it feels very inconsistent in a way that is often jarring. Thus, I set out
to build a programming language just, for myself, that took the good parts of Common Lisp and added
some modern features.


* New parameter lists

  The goal with FN's new parameter lists is to create simpler, terser syntax while maintaining
  important features, namely keyword arguments, optional arguments, and variadic arguments. To
  achieve this. To achieve this, we use Scheme-style optional argument syntax. Since keywords as
  such do not exist in FN, we use quoted symbols to denote keyword arguments. Other than this
  change, calling a function with keyword arguments works identically to how it works in Common
  Lisp. On the parameter list side of things, keyword arguments are denoted identically to normal
  positional or optional arguments, except that the symbol name is quoted. Thus it is possible to
  make required keyword arguments.

  Variadic arguments can be accepted using the ampersand symbol (&) followed by a variable name for
  the list of trailing arguments.

  #+BEGIN_SRC fn
  (defn func (positional-arg (optional-arg "init") ('keyword-arg "key-init"))
    (function-body))
  #+END_SRC

  And here are some translations from Common Lisp:

  #+BEGIN_SRC fn
  (defun operator (operand0 &rest operands) ...)
  ;; => (in FN)
  (defn operator (operand0 & operands) ...)

  (defun log (x &optional (base 10)) ...)
  ;; => lists replace &optional
  (defn log (x (base 10)) ...)

  (defun sort (seq &key (test #'< test-p) (ascending t)) ...)
  ;; => keyword arguments replace &key
  (defn sort (seq ('test #'<) ('ascending t)) ...)
  #+END_SRC

  #+BEGIN_SRC fn
  ;; define a function requiring a keyword argument
  (defn func ('req-key ('opt-key "default")) 
    (function-body))

  (func) ;=> error (needs req-key)
  (func 'req-key 6) ;=> okay (opt-key = "default")
  (func 'opt-key 9) ;=> error (needs req-key)
  (func 'req-key 6 'opt-key 9) ;=> okay
  #+END_SRC


* Type System 

** Object system

New types can be defined using the ~deftype~ special form. Types are first-class objects and invoking
~deftype~ causes creation of a global type object of the specified name. However, there is no way to
create new type objects other than by using ~deftype~, i.e. there are no non-global types.

The *internal slots* of an object are the key-value pairs it contains. They can be accessed with
~slot-value~. The *constructor* of a type is a function that creates new instances of a type. It is
usually generated automatically by ~deftype~, however it may be manually specified via the options.

#+BEGIN_SRC fn
;; Type and protocol creation
(deftype Type-Name (slots...) options...)
;; Instantiate an arbitrary object by manually assigning slot values
(instantiate TYPE SLOT-VALUES...)
;; to invoke the constructor, use the object as a Callable instance
(TYPE ARGS...)

;; Access slots directly
(slot-value OBJ SLOT)
(set (slot-value OBJ SLOT) NEW-VALUE)

;; Access slots via the generic accessors
(@ OBJ SLOT)
#+END_SRC


** Protocols and Implementation

A protocol is a group of functions whose behaviors are decided based upon the types of some of their
arguments, called dispatch arguments.

#+BEGIN_SRC fn
(defproto Proto-Name (types...)
  (function-name-1 arg-list options...)
  (function-name-2 arg-list options...))
(defimpl Proto-Name (types...)
  function-name-1 implementation-function-1
  function-name-2 implementation-function-2)

;; Example: the built-in Mul protocol
(defproto Mul (l r)
  (mul (l r) "Multiply two numbers"))

;; Example: Implementing multiplication on a custom 2D vector type
(deftype Vec2 (x y))

(defn vec2-scalar-mul (s v)
  "Multiply a vec2 by a scalar"
  (Vec2 (* s v.x) (* s v.y)))


;; define for all four scalar combinations
(defimpl Mul (Num Vec2)
  mul vec2-scalar-mul)
(defimpl Mul (Vec2 Num)
  mul $(vec2-scalar-mul $1 $0))

(* (Vec2 1.0 2.3) -2)
;;=> (Vec2 -2.0 -4.6)
(* 1.1 (Vec2 1.2 1.3))
;;=> (Vec2 1.32 1.43)

#+END_SRC


** Built-in types

The following types are built into fn.

*Atomic types*
- Symbol :: symbol
- Bool :: boolean True or False
- Null :: unassigned value 
- Num :: 64-bit floating-point number
- String :: character string

*Structure types*
- List :: singley-linked list
- Dict :: general-purpose hash table
- Arr :: generic one-dimensional (for now) array
- Type :: the type of types

Foreign data structures and bit array types will be added in the future.


** Built-in Protocols

- Add :: used for the + operator
- Sub :: used for the - operator
- Mul :: used for the * operator
- Div :: used for the / operator
- Callable :: allows the type to be called like a function
- Get :: specifies behavior of @


** Misc Type Functions

Use ~(type-of OBJ)~ to get the type of an object.

The slots of an object can be accessed directly using ~(slot-value OBJ SLOT)~. Mutable slots can be
set using ~(set (slot-value ...) ...)~.


* Version 0 Language Spec

If anyone other than me ever tries to read this, I'm sorry. This is a "complete" specification of
version 0 of the fn programming language (i.e. complete enough for me, the language designer, to
remember the decisions I've made so far).

** Flow control

- cond
- do
- if
- let

*if* works as it always does and *do* works like ~PROGN~ does in Common Lisp or ~begin~ in Scheme.

*cond* has its syntax changed so omit the second level of parentheses. Instead, it takes an
alternating series of tests and results, and automatically groups them into pairs.

#+BEGIN_SRC fn
  ;; syntax
  (cond
    test0
      result0
    test1
      result1)

  ;; example. returns "fizz" if x is a multiple of 3, "buzz" if it's a multiple of 5, "fizzbuzz" if
  ;; it's both, and x as a string if it's neither.
  (defn foo (x)
    (cond
      (= (mod x 15) 0) "fizzbuzz"
      (= (mod x 5) 0) "buzz"
      (= (mod x 3) 0) "fizz")
      (True (String x)))
#+END_SRC


~let~ has been modified in a similar way, doing away with the second layer of parentheses in the
binding specs

#+BEGIN_SRC fn
  (let (a 2
        b 3
        c 4)
    (+ a b c))
  ;; => 9

  ;; let behaves like scheme's letrec
  (defn reverse-map (f lst)
    (let (iter
           (fn (acc src)
             (if src
                 (iter (cons (f src.hd) acc)
                       src.tl)
                 acc)))
      (iter [] lst)))
                   
#+END_SRC


** Function creation

- fn
- $ (dollar sign syntax)


** Type System 

Version 0 will implement the complete type system as described in Type System at the top level of
this document.


** Generic accessors

*** @

The generic getter is ~@~. It gets values from objects given some key.

#+BEGIN_SRC fn
;; function signature for @
(defn @ (object key0 & keys)
  ...)
#+END_SRC fn

When multiple keys are passed as arguments, each successive key is used to access the value from the
previous key. E.g. ~(@ obj key1 key2)~ is equivalent to ~(@ (@ obj key1) key2)~.

The default behavior for ~@~ on new types is to act like ~slot-value~.


*** dot notation (might remove)

The dot (.) is used as a shorthand for ~@~ when the object is a variable and the key is a symbol. For
example, the following two expressions are equivalent:

#+BEGIN_SRC fn
;; 1.
object.slot
;; 2.
(@ object 'slot)
#+END_SRC

In fact, the reader converts the former expression to the latter before evaluation.

Multiple dots can also be used to supply more keys:

#+BEGIN_SRC fn
object.slot1.slot2
;; is equivalent to
(@ object 'slot1 'slot2)
#+END_SRC


*** Default Callable (Potential alternative to dot notation)

The dot is an attractive syntax because it allows tree descent with the addition of only one
character of syntax per depth. An alternative syntax would be achieved by giving all objects a
default Callable protocol implementation that invokes ~@~ on the object with the specified arguments.
E.g:

;; this
object.key.key2.key3
;; would be replaced by this
(object 'key1 'key2 'key3)

I guess we could also do both, but that seems like overkill. I'm leaning towards keeping dot notation.


*** set

The generic setter is ~set~.

#+BEGIN_SRC fn
(defmacro set (place value)
  ...)

;; define a mutable variable
(defvar x 27)
x
;;=> 27
(set x 32)
x
;;=> 32

;; mutate the field of an object
(set obj.slot 'funk)
;; equivalent w/o dot notation
(set (@ obj slot) 'funk)
#+END_SRC

The place can be a variable name, in which case the variable is mutated. It may also be an ~@~ form,
which will invoke the generic


** Definition

These are all the variable definition facilities in fn

#+BEGIN_SRC fn
;; define a constant variable
(def VAR VALUE "Doc string")
;; define a mutable variable
(defvar VAR VALUE "Doc string")
;; define a function
(defn VAR (ARG-LIST...)
  "Doc string"
  (options FUNCTION-OPTIONS...)
  FUNCTION-BODY) 

#+END_SRC


** Macros

#+BEGIN_SRC fn
;; define a macro
(defmacro NAME (ARG-LIST...)
  "Doc string"
  MACRO-BODY)
#+END_SRC

Macros work in the usual lisp way, and they are unsanitary. Macro functions may return function
objects as part of their outputs. This is encouraged as a way to prevent lexical variable
definitions from colliding with global module or function names.

*Note:* In the future, some facility e.g. a ~global~ special form may be introduced which allows global
variables to be accessed from macros without needing to include them as literals. Such a form would
possibly return a pointer object that unambiguous denoted the variable being referenced.


** Pattern matching

Will not be implemented with the first version


** Standard Library

- @
- +,-,*,/
- add,sub,mul,div (corresp. to Add, Sub, Mul, Div protocols)
- call (w/ Callable protocol)
- get (w/ Get protocol, used by @)
- print
- random
- set (macro)
- slot-value
- type-of


** Complete list of special operators

- cond
- def
- defimpl
- defmacro
- defn
- defproto
- defvar
- do
- fn
- let
- quote
- quasiquote
- unquote


** Syntax

Syntax is standard lisp parenthesized prefix notation. The following are all the special syntax
characters:

$()[]{}\;"',.

all other non-whitespace characters are symbol constituents, that is, they are parsed as atoms, i.e.
as symbols or numbers.


*** Delimiters

In typical lisp fashion, () are the delimiters denoting lists. In addition, [] and {} are matched
delimiters for reading lists and dicts. In fact, they are converted by the reader.

[a b c] -> (List a b c),
and
{:a 0 :b 1} -> (Dict :a 0 :b 1)

Also, "" reads UTF-8 strings. It uses C/C++ escape sequences because those are better than the lisp
ones and support Unicodes. Get over it.


*** Comments

There are no multi-line comments in fn. Only line-end comments, started by semicolons, are
supported.


*** Dollar sign

See function creation.


*** Quotation

Normal quote works as it usually does in Lisp. Quasiquote works the same but lacks a destructive
splice.


*** Escaping

Escaping is when a backslash (/) character is placed in front of another character, thereby turning it
into a symbol constituent.. Any character can be escaped in any context except for within a string, (where string
escaping rules apply instead).


*** Dot notation

See Generic Accessors


* Misc Notes and Ideas

** Important idea: global pointers

I think it would be very useful to introduce a "pointer" data type (a better name might be GUID,
place, or address) which is simply an unambiguous reference to some global variable (possibly also
local?). GUID syntax could start with #G (or something) and would be very much analogous to symbols
in Common Lisp, in that GUIDs, like CL's symbols, would be standalone places to store objects. This
also allows an elegant alternative to gensyms, i.e. randomly-generated, disposable places.


** Future Features

Once I've implemented everything up to version 0, I'm going to get to work on a module system as
well as a way to sanitize macros where necessary (probably via some sort of GUID for global
variables). That will be version 0.1. From there, the next steps will be to add multithreading and
FFI and to otherwise flesh out the standard library, which eventually will lead me to version 0.2
(and possibly 0.3 depending on how I break up the work). I will not increment to version 1.0 until
the interpreter is rewritten in C++. Further goals include implementing JIT compilation using LLVM,
adding a scientific computing/linear algebra library, and adding networking and IPC modules.



** VM version 0

The initial implementation (not the full version 0) will omit macros, varargs, and any sort of
clever optimization.


*** Call stack

Each stack frame will provide the program with (up to) 256 clean registers. To create closures, we
borrow the concept of upvalues from Lua. The CALL opcode takes three arguments: the return value
register, the register containing the first argument, and the number of arguments being passed.

Eventually we will apply the Lua calling optimization where the argument list is at the end of the
stack and so can be reused in the next function call. For now however, calling does this:

- check the tag to make sure that the value is a function
- create a new stack frame
- copy all active registers to the stack frame
- copy the return address to the stack frame
- copy the arguments to the fresh registers
- jump to the function bytecode

While returning does this:

- copy upvalues to their location on the heap
- restore previous register values from the stack frame
- jump to the return address (the caller address plus 1)


*** Values

Values have a 4-byte tag describing their types and an 8-byte value, as in Lua. In the future we may
move to a single 8-byte value with the tag built in to the first few bits. This would result in some
weirdness, for instance having floats and fixnums that are 60-62 bits instead of a full 64.
Moreover, it would require the implementation of some sort of virtual memory scheme so that object
pointers could fit into 48 bits (leaving 16 bits for the tag), which precludes the passing of native
pointers as immediate values. The biggest performance gain here would be the fact that a single
register could be used for each machine register, and also that all reads and writes could happen on
64-bit boundaries. It would also greatly reduce data usage. The downsides are greatly increased
implementation complexity, loss of floating-point precision, and the need to treat native code as a
special object. However, realistically, being able to pass around native pointers in single
registers is not especially useful.

Alternatively, 

In VM 0, the VM is only aware of the following types of values:

- numbers
- strings
- symbols
- objects
- special constants like True, False, and Null
- raw bytes


*** Symbols and variables

Obviously symbols are going to be internalized. This can be done using the VM's INTERN op. Every
time a new string is internalized, it is added to a hash table and a unique 16-bit identifier is
assigned to it. Then, a copy of the string is added to an array indexed by symbol IDs so that the
name can be recovered easily.


*** Creating Objects using only Bytecode

There are several special load instructions available to the VM that can be used to load 

Most objects in FN consist of a reference to a Type object and a hashtable. There are instructions
to add keys, to set values, and to check whether a key exists in the table.

There is a special VM op called LDBYTES which loads bytes directly into the data part of a register.
This can be used, among other things, to create strings.

There is also LDNUM to load numeric constants.


*** Compilation

The unit of compilation is the file. We will compile in two passes. The first pass makes a list of
all top-level definitions and creates bytecode to


** VM Tags

We have these types

Atomic types*
- Symbol :: symbol
- Bool :: boolean True or False
- Null :: unassigned value 
- Num :: 64-bit floating-point number
- String :: character string

*Structure types*
- List :: singley-linked list
- Dict :: general-purpose hash table
- Arr :: generic one-dimensional (for now) array
- Type :: the type of types

So, what if we implemented variable-width tags as such:

- 2-bit tags for numbers (and eventually fixnums)
- 16-bit tags for everything else
- reserve tags for Bytes (up to 6 bytes), Function, True, False, Nil, Num, String, Array, Dict,
  Empty, and Cons (eventually big-int)


*** Tagging details

First three bits:
- 000 :: number
- 001 :: cons
- 010 :: string
- 011 :: object (i.e. hash table)
- 100 :: function
- 101, 110 :: reserved for future extensions
- 111 :: extended tag

First 8 bits:
- Null  :: e0
- True  :: e1
- False :: e2
- Sym   :: f0
- Bytes :: f1

*Note:* If we assume that all pointers have addresses that are multiples of 4, we can actually get
away with using the first two bits for a tag. In fact, if we assume 8-bit alignment, we can use a
full 3 bits for the tag. (61-bit pointers). Not counting an extended tag and the numeric immediate
type(s), that gives us up to 6 different pointer types that can be encoded directly into the tag
while still leaving room for all special values, symbols, and functions.

*** Objects:

8 bytes of metadata
8 byte type pointer?


**** Note: future tagging extensions

If we ever find ourselves needing more 3-bit tags, we have some options:

- combining two or more pointer values into a single tag and adding data on the business end of the
  pointer to differentiate them
  - e.g. making objects and arrays the same and adding a 64-bit tag to them
- further shortening numbers by combining the number tag w/ the extended tag
- changing object representation could make it so that objects, arrays, and strings can all be
  stored under the same tag. Type information must simply be encoded in the first 8 bytes of data,
  and this could include things like number of elements, mutability, and so on. Since Types will
  also be regular objects, we could directly embed the 61-bit type pointer and still have 3 bits to
  work with for type information.


** VM 0 object representation

Objects in fn are usually expected to have simple types which rarely have more than 10 fields and
often have 1 or 2.


** VM version 0

- heavily inspired by Lua 5 VM
# - 256 registers forming a cyclic stack
#   - each register has a one-byte tag describing it
#   - internally an array of 256 * 9 = 2304 bytes
- must figure out ahead of time where each variable, intermediate value, etc can go on the stack
  - at the end of the stack frame is the call stack, which can be used as the beginning of the next
    stack frame if you're clever
  - this can be computed by counting the number of function arguments that need to be passed
- 32-bit opcodes. First byte is operation, other three are registers and/or constants/variables
- 72-bit values. 8-bit tag describing type follow by 64-bits of data. These 64-bits are usually an
  object pointer. The first two bytes of an object are the GUID of the variable for its type, and
  the rest of the object is tightly-packed 9-byte fields
- 12-byte variables and values. The first two bytes are a tag describing the type and nature of the
  variable. The next two are the GUID of the type of this variable (where applicable). Finally,
  there's a 64-bit piece of data corresponding to the

What if we put the tag inside the data?

- one 2-bit tag for numbers (just shift left to convert to normal floating point instructions)
- other types have 32(?)-bit tag including 30-bit GUID and 32-bit OID.
- probably not

*** Op codes

# should this have multiple versions?
ldconst(Reg A, 16-bit CID)
ldvar(Reg A, 16-bit GUID)
ldaddr(Reg A, 16-bit OID)



# Writes a register or range of registers to a location in memory
write(Reg A (dest), Reg B (src), Reg C (length))
read(Reg A (dest))

call(Reg A (return val), Reg B (call frame), Reg C (frame size))

closure(Reg A, Reg B (num-args), Reg C (and-arg))


** Version 0 lexer tokens

(delimiters)
left-paren, right-paren, left-bracket, right-bracket, left-brace, right-brace

(unary operators)
quote, backtick, comma, comma-splice

dollar-paren, dollar-bracket, dollar-brace

(binary operator)
dot

(literals)
number, string, symbol

comments

eof


** Version 0 grammar

#+BEGIN_SRC haskell
program -> expr* EOF
expr    -> constant
         | compound
         | unary
         | dot

constant -> STRING
          | NUMBER

compound -> paren
          | bracket
          | brace
paren    -> "(" expr* ")"
bracket  -> "[" expr* "]"
brace    -> "{" expr* "}"

unary      -> quote
            | quasiquote
            | unquote
            | unquote-splicing
            | dollar
quot       -> "'" expr
quasiquot  -> "`" expr
unquot     -> "," expr
unquot-splice -> ",@" expr
dollar     -> "$(" expr* ")"
            | "$[" expr* "]"
            | "${" expr* "}"
            | "$" quasiquote

dot -> SYMBOL "." SYMBOL
     | dot "." SYMBOL
#+END_SRC

#+BEGIN_SRC common-lisp
  (defun token-is? (tok kind)
    (eq (token-kind tok) kind))

  (make-parser
   ;; first form is grammar
   ((program -> (* expr) @eof)
    (expr -> constant / group / unary / dollar / dot)

    (constant -> @string / @number)

    (group -> paren / bracket / brace)
    (paren -> @left-paren (* expr) @right-paren)
    (bracket -> @left-bracket (* expr) @right-bracket)
    (brace -> @left-brace (* expr) @right-brace)

    (unary -> quot / quasiquot / unquot / unquot-splicing)
    (quot -> @quot expr)
    (quasiquot -> @backtick expr)
    (unquot -> @comma expr)
    (unquot-splice -> @comma-splice expr)

    (dollar -> @dollar-paren (* expr) @right-paren
            / @dollar-bracket (* expr) @right-bracket
            / @dollar-brace (* expr) @right-brace
            / @dollar-backtick expr)

    (dot -> var / dot @dot var)
    (var -> @symbol))

   ;; remaining forms are callbacks for nonterminals. Whenever a reduce is performed, the callback
   ;; corresponding to the generated nonterminal is invoked with a single argument, a list of the
   ;; POBJs used to make this pattern.
   (constant #'constant-fun)
   (dot #'dot-fun)
   (var #'var-fun)
   )

#+END_SRC


** Registers and calling conventions

Every call frame provides up to 256 fresh registers.


** Alternative: Virtual Memory and Built-in tags

I don't think I'll do this because keeping full 64-bit pointers would make foreign code interop and
low-level code writing much easier.

Suppose we limit ourselves to 56-bit pointers, which is still more than enough memory. Then, we have
8 bytes of the string which we can use as a type tag. We can use a variable-length tagging scheme to
get 62-bit fixed-width integers and if we pick tag 00 (binary) for those, we can use CPU native
integer arithmetic operations. It would also be possible to truncate 64-bit floating point numbers
to 62-bit precision by dropping the two rightmost digit, allowing use of x87 hardware and making
passing around of numbers, etc, much more efficient. A downside of this approach is that it would
give us less than the maximum 256 possible type tags that exist right now.


** Stdlib note: globbing

Globbing file names would be an extremely useful feature for interactive programming and
system-script writing.

#+BEGIN_SRC fn
(def glob-files (pattern)
  "Returns a list of file and/or directory names matching a bash-style glob string."
  (options (type (String -> List)))
  ...)
#+END_SRC 




