* Introduction

fn is a programming language in the Lisp family. It will feature a robust and streamlined object
system, an intuitive module-based approach to code organization, powerful metaprogramming
facilities, and a variety of quality of life features that aid in writing especially concise code
without sacrificing clarity.

** fn compared to other dialects of Lisp

Compared to most dialects of Lisp, fn has a small number of special forms, several new syntactic
conveniences, and a strong focus on its native object system. The object system strives to avoid
several of CLOS, namely its feeling tacked-on to the rest of the language and being rather verbose.

In addition, fn code is homoiconic like Common Lisp, allowing writing of macros in the traditional
Lisp way, which I greatly prefer to the hygienic macros and templates of e.g. Racket or Scheme.


** Implementation notes

- Everything is implemented in Common Lisp. The only supported implementation is SBCL. No particular
  effort is made to maintain ANSI compliance, although most of the code is ANSI anyway.
- This code is only tested on a handful of my personal computers, all of which run Arch Linux.
- I am currently in the process of rewriting fn. The previous version, which was nearly a feature
  complete version 0, was built as a layer on top of Common Lisp, using the Common Lisp reader and
  macros to implement almost all of its features. This new version will be a proper interpreter.


** Inspirations/Credit

fn's design was strongly inspired by Clojure, Python, Common Lisp, and Haskell. All four of those
are great programming languages. Honestly, if I could get a full version of Clojure that didn't need
the JVM or the CLR, I might not have bothered making a new programming language, although I really
don't care for pure functionality as much as Rich Hickey. In that respect I prefer Common Lisp. When
you get down to it, Common Lisp can be massaged into a very good language and development
environment using FOSS tools and libraries such as Quicklisp, Alexandria, and Emacs+SLIME. Common
Lisp can be further customized to the extent that even built-in special forms and syntax can be
overwritten, which is what I used to prototype early versions of fn. However, I have two serious
problems with Common Lisp. Firstly, it is too much work to configure a Common Lisp environment
compared to, say, Python or Haskell, which are essentially ready to go out of the box. While this
can be overcome by patience, a more significant problem is that since Common Lisp is built out of
so many different pieces, it feels very inconsistent in a way that is often jarring. Thus, I set out
to build a programming language just, for myself, that took the good parts of Common Lisp and added
some modern features.


* New parameter lists

  The goal with FN's new parameter lists is to create simpler, terser syntax while maintaining
  important features, namely keyword arguments, optional arguments, and variadic arguments. To
  achieve this. To achieve this, we use Scheme-style optional argument syntax. Since keywords as
  such do not exist in FN, we use quoted symbols to denote keyword arguments. Other than this
  change, calling a function with keyword arguments works identically to how it works in Common
  Lisp. On the parameter list side of things, keyword arguments are denoted identically to normal
  positional or optional arguments, except that the symbol name is quoted. Thus it is possible to
  make required keyword arguments.

  Variadic arguments can be accepted using the ampersand symbol (&) followed by a variable name for
  the list of trailing arguments.

  #+BEGIN_SRC fn
  (def (func positional-arg (optional-arg "init") ('keyword-arg "key-init"))
    (function-body))
  #+END_SRC

  And here are some translations from Common Lisp:

  #+BEGIN_SRC fn
  (defun operator (operand0 &rest operands) ...)
  ;; => (in FN)
  (def (operator operand0 & operands) ...)

  (defun log (x &optional (base 10)) ...)
  ;; => lists replace &optional
  (def (log x (base 10)) ...)

  (defun sort (seq &key (test #'< test-p) (ascending t)) ...)
  ;; => keyword arguments replace &key
  (def (sort seq ('test <) ('ascending t)) ...)
  #+END_SRC

  #+BEGIN_SRC fn
  ;; define a function requiring a keyword argument
  (def (func 'req-key ('opt-key "default")) 
    (function-body))

  (func) ;=> error (needs req-key)
  (func 'req-key 6) ;=> okay (opt-key = "default")
  (func 'opt-key 9) ;=> error (needs req-key)
  (func 'req-key 6 'opt-key 9) ;=> okay
  #+END_SRC


* Type System

** Type definition

New types can be defined using the ~deftype~ special form. Types are first-class objects and invoking
~deftype~ causes creation of a global type object of the specified name. However, there is no way to
create new type objects other than by using ~deftype~, i.e. there are no non-global types.

The *fields* of an object are the key-value pairs it contains. They can be accessed with ~field-value~
or ~@~. Objects may be instantiated by calling the type as

By convention, type and protocol names begin with capital letters.

#+BEGIN_SRC fn
;; Type and protocol creation
(deftype (Type-Name args...) options...)
;; at this time no options are supported

;; to invoke the constructor, use the type as a function
(Type-Name args...)

;; Access fields directly
(field-value obj 'field)
(set (field-value obj 'field) new-value)

;; Access fields via the generic accessors
(@ obj 'field)
(set (@ obj 'field) new-value)
;; or, equivalently,
obj.field
(set obj.field new-value)
;; this dot notation is preferred wherever possible

#+END_SRC

*** Future features

Options should allow customization of the object's internal representation, constructor, and fields.
E.g. fields may be marked mutable or have type restrictions applied.


** Protocols and Implementation

A protocol is a group of functions whose behaviors are decided based upon the types of some of their
arguments, called dispatch arguments.

#+BEGIN_SRC fn
(defproto (Proto-Name types...)
  (method-1 args)
  (method-2 args))
(defimpl (Proto-Name types...)
  method-1 implementation-function-1
  method-2 implementation-function-2)

;; Example: the built-in Mul protocol
(defproto (Mul L R)
  (mul (L R) "Multiply two numbers"))

;; Example: Implementing multiplication on a custom 2D vector type
(deftype (Vec2 x y))

(def (vec2-scalar-mul s v)
  "Multiply a vec2 by a scalar"
  (Vec2 (* s v.x) (* s v.y)))


;; define for all four scalar combinations
(defimpl (Mul Num Vec2)
  mul vec2-scalar-mul)
(defimpl (Mul Vec2 Num)
  mul $(vec2-scalar-mul $1 $0))

(* (Vec2 1.0 2.3) -2)
;;=> (Vec2 -2.0 -4.6)
(* 1.1 (Vec2 1.2 1.3))
;;=> (Vec2 1.32 1.43)

#+END_SRC


*** Future features

Protocols should be able to have methods that don't create global function objects. Such methods
could only be accessed through the protocol object. This would be helpful, e.g. for the ~Mul~
interface because the ~mul~ function is redundant compared to the ~*~ operator.

I would like to add functionality where 


** Built-in types

The following types are built into fn.

*Atomic types*
- Symbol :: symbol
- Bool :: boolean denoted ~true~ or ~false~
- Null :: unassigned value denoted ~null~
- Num :: 64-bit floating-point number

*Structure types*
- List :: singley-linked list
- Table :: general-purpose hash table
- Array :: generic one-dimensional vector
- Type :: the type of types
- String :: character string

Foreign data structures and bit array types will be added in the future.


** Built-in Protocols

- Add :: used for the + operator
- Sub :: used for the - operator
- Mul :: used for the * operator
- Div :: used for the / operator
- Callable :: allows the type to be called like a function
- Get :: specifies behavior of @


** Misc Type Functions

Use ~(type-of obj)~ to get the type of an object.

The slots of an object can be accessed directly using ~(slot-value OBJ SLOT)~. Mutable slots can be
set using ~(set (slot-value ...) ...)~.


* Version 0 Spec

If anyone other than me ever tries to read this, I'm sorry. This is a "complete" specification of
version 0 of the fn programming language (i.e. complete enough for me, the language designer, to
remember the decisions I've made so far).

** Core language cheat sheet

This sample code contains every special form in fn.

#+BEGIN_SRC fn
;; variable definition
(def var value)
(def (fun-var arg*) body*)
(defvar var value)

;; type system
(deftype (Type arg*))
(defproto (Proto-Name type-var*)
  (function-name arg*)
  (function-name arg*))
(defimpl (Proto-Name types)
  function-name function
  function-name function)

;; get/set
(get obj field)
(@ obj key)
(set place value)

;; function creation
(fn (x) (+ x 2))
$(+ $ 2)
(dollar-fn (+ $ 2))

;; control flow
(apply fun lst)
(do expr*)
(let (var1 val1
      var2 val2
      (fun-var arg*)
        (body))
  expr*)
(if condition
    then-expr
    else-expr)
(cond
  condition1 
    expr1
  condition2 
    expr2)
(case obj
  pattern1
    expr1
  pattern2
    expr2)

;; code as data/macros
(defmacro (name arg*)
  macro-body)
'x
(quote x)
`(a b ,(+ 2 4))
(quasiquote (a b (unquote (+ 2 4))))

#+END_SRC


** Flow control

- cond
- do
- if
- let

*if* works as it always does and *do* works like ~PROGN~ does in Common Lisp or ~begin~ in Scheme.

*cond* has its syntax changed so omit the second level of parentheses. Instead, it takes an
alternating series of tests and results, and automatically groups them into pairs.

#+BEGIN_SRC fn
  ;; syntax
  (cond
    test0
      result0
    test1
      result1)

  ;; example. returns "fizz" if x is a multiple of 3, "buzz" if it's a multiple of 5, "fizzbuzz" if
  ;; it's both, and x as a string if it's neither.
  (defn foo (x)
    (cond
      (= (mod x 15) 0) "fizzbuzz"
      (= (mod x 5) 0) "buzz"
      (= (mod x 3) 0) "fizz")
      (true (String x)))
#+END_SRC


~let~ has been modified in a similar way, doing away with the second layer of parentheses in the
binding specs

#+BEGIN_SRC fn
  (let (a 2
        b 3
        c 4)
    (+ a b c))
  ;; => 9

  ;; let behaves like scheme's letrec
  (defn reverse-map (f lst)
    (let (iter
           (fn (acc src)
             (if src
                 (iter (cons (f src.hd) acc)
                       src.tl)
                 acc)))
      (iter [] lst)))
                   
#+END_SRC


** Function creation

- fn
- $ (dollar sign syntax)


** Type System 

Version 0 will implement the complete type system as described in Type System at the top level of
this document.


** Generic accessors

*** @

The generic getter is ~@~. It gets values from objects given some key.

#+BEGIN_SRC fn
;; function signature for @
(defn @ (object key0 & keys)
  ...)
#+END_SRC fn

When multiple keys are passed as arguments, each successive key is used to access the value from the
previous key. E.g. ~(@ obj key1 key2)~ is equivalent to ~(@ (@ obj key1) key2)~.

The default behavior for ~@~ on new types is to act like ~slot-value~.


*** dot notation

The dot (.) is used as a shorthand for ~@~ when the object is a variable and the key is a symbol. For
example, the following two expressions are equivalent:

#+BEGIN_SRC fn
;; 1.
object.slot
;; 2.
(@ object 'slot)
#+END_SRC

In fact, the reader converts the former expression to the latter before evaluation.

Multiple dots can also be used to supply more keys:

#+BEGIN_SRC fn
object.slot1.slot2
;; is equivalent to
(@ object 'slot1 'slot2)
#+END_SRC


*** Default Callable (Potential alternative to dot notation)

The dot is an attractive syntax because it allows tree descent with the addition of only one
character of syntax per depth. An alternative syntax would be achieved by giving all objects a
default Callable protocol implementation that invokes ~@~ on the object with the specified arguments.
E.g:

;; this
object.key.key2.key3
;; would be replaced by this
(object 'key1 'key2 'key3)

I guess we could also do both, but that seems like overkill. I'm leaning towards keeping dot notation.


*** set

The generic setter is ~set~.

#+BEGIN_SRC fn
(defmacro set (place value)
  ...)

;; define a mutable variable
(defvar x 27)
x
;;=> 27
(set x 32)
x
;;=> 32

;; mutate the field of an object
(set obj.slot 'funk)
;; equivalent w/o dot notation
(set (@ obj slot) 'funk)
#+END_SRC

The place can be a variable name, in which case the variable is mutated. It may also be an ~@~ form,
which will invoke the generic


** Definition

These are all the variable definition facilities in fn

#+BEGIN_SRC fn
;; define a constant variable
(def VAR VALUE "Doc string")
;; define a mutable variable
(defvar VAR VALUE "Doc string")
;; define a function
(defn VAR (ARG-LIST...)
  "Doc string"
  (options FUNCTION-OPTIONS...)
  FUNCTION-BODY) 

#+END_SRC


** Macros

#+BEGIN_SRC fn
;; define a macro
(defmacro NAME (ARG-LIST...)
  "Doc string"
  MACRO-BODY)
#+END_SRC

Macros work in the usual lisp way, and they are unsanitary. Macro functions may return function
objects as part of their outputs. This is encouraged as a way to prevent lexical variable
definitions from colliding with global module or function names.

*Note:* In the future, some facility e.g. a ~global~ special form may be introduced which allows global
variables to be accessed from macros without needing to include them as literals. Such a form would
possibly return a pointer object that unambiguous denoted the variable being referenced.


** Pattern matching

Will not be implemented with the first version


** Standard Library

- @
- +,-,*,/
- add,sub,mul,div (corresp. to Add, Sub, Mul, Div protocols)
- call (w/ Callable protocol)
- get (w/ Get protocol, used by @)
- print
- random
- set (macro)
- slot-value
- type-of


** Complete list of special operators

- apply
- case
- cond
- def
- defimpl
- defmacro
- defn
- defproto
- defvar
- do
- fn
- let
- quote
- quasiquote
- unquote


** Syntax

Syntax is standard lisp parenthesized prefix notation. The following are all the special syntax
characters:

$()[]{}\;"',.

all other non-whitespace characters are symbol constituents, that is, they are parsed as atoms, i.e.
as symbols or numbers.


*** Delimiters

In typical lisp fashion, () are the delimiters denoting lists. In addition, [] and {} are matched
delimiters for reading lists and dicts. In fact, they are converted by the reader.

[a b c] -> (List a b c),
and
{:a 0 :b 1} -> (Dict :a 0 :b 1)

Also, "" reads UTF-8 strings. It uses C/C++ escape sequences because those are better than the lisp
ones and support Unicodes. Get over it.


*** Comments

There are no multi-line comments in fn. Only line-end comments, started by semicolons, are
supported.


*** Dollar sign

See function creation.


*** Quotation

Normal quote works as it usually does in Lisp. Quasiquote works the same but lacks a destructive
splice.


*** Escaping

Escaping is when a backslash (/) character is placed in front of another character, thereby turning it
into a symbol constituent.. Any character can be escaped in any context except for within a string, (where string
escaping rules apply instead).


*** Dot notation

See Generic Accessors


* Misc Notes and Ideas

** Important idea: global pointers

I think it would be very useful to introduce a "pointer" data type (a better name might be GUID,
place, or address) which is simply an unambiguous reference to some global variable (possibly also
local?). GUID syntax could start with #G (or something) and would be very much analogous to symbols
in Common Lisp, in that GUIDs, like CL's symbols, would be standalone places to store objects. This
also allows an elegant alternative to gensyms, i.e. randomly-generated, disposable places.


** Future Features

Once I've implemented everything up to version 0, I'm going to get to work on a module system as
well as a way to sanitize macros where necessary (probably via some sort of GUID for global
variables). That will be version 0.1. From there, the next steps will be to add multithreading and
FFI and to otherwise flesh out the standard library, which eventually will lead me to version 0.2
(and possibly 0.3 depending on how I break up the work). I will not increment to version 1.0 until
the interpreter is rewritten in C++. Further goals include implementing JIT compilation using LLVM,
adding a scientific computing/linear algebra library, and adding networking and IPC modules.



** Version 0 lexer tokens

(delimiters)
left-paren, right-paren, left-bracket, right-bracket, left-brace, right-brace

(unary operators)
dollar-sign, quote, backtick, comma, comma-splice

(binary operator)
dot

(literals)
number, string, symbol

comments

eof


** Version 0 grammar

#+BEGIN_SRC haskell
program -> expr* EOF
expr    -> constant
         | compound
         | unary
         | dot

constant -> STRING
          | NUMBER

compound -> paren
          | bracket
          | brace
paren    -> "(" expr* ")"
bracket  -> "[" expr* "]"
brace    -> "{" expr* "}"

unary      -> quote
            | quasiquote
            | unquote
            | unquote-splicing
            | dollar
quot       -> "'" expr
quasiquot  -> "`" expr
unquot     -> "," expr
unquot-splice -> ",@" expr
dollar     -> "$(" expr* ")"
            | "$[" expr* "]"
            | "${" expr* "}"
            | "$" quasiquote

dot -> SYMBOL "." SYMBOL
     | dot "." SYMBOL
#+END_SRC

#+BEGIN_SRC common-lisp
  (defun token-is? (tok kind)
    (eq (token-kind tok) kind))

  (make-parser
   ;; first form is grammar
   ((program -> (* expr) @eof)
    (expr -> constant / group / unary / dollar / dot)

    (constant -> @string / @number)

    (group -> paren / bracket / brace)
    (paren -> @left-paren (* expr) @right-paren)
    (bracket -> @left-bracket (* expr) @right-bracket)
    (brace -> @left-brace (* expr) @right-brace)

    (unary -> quot / quasiquot / unquot / unquot-splicing)
    (quot -> @quot expr)
    (quasiquot -> @backtick expr)
    (unquot -> @comma expr)
    (unquot-splice -> @comma-splice expr)

    (dollar -> @dollar-paren (* expr) @right-paren
            / @dollar-bracket (* expr) @right-bracket
            / @dollar-brace (* expr) @right-brace
            / @dollar-backtick expr)

    (dot -> var / dot @dot var)
    (var -> @symbol))

   ;; remaining forms are callbacks for nonterminals. Whenever a reduce is performed, the callback
   ;; corresponding to the generated nonterminal is invoked with a single argument, a list of the
   ;; POBJs used to make this pattern.
   (constant #'constant-fun)
   (dot #'dot-fun)
   (var #'var-fun)
   )

#+END_SRC


** Bytecode version 0

All instructions are 1 byte long. The first machine will be a register machine, because it's going
to be a register machine eventually anyway.


** Registers and calling conventions

Each general-purpose register has two parts: an 8-bit tag and a 64-bit value. The tag indicates the
type of the data. Each thread has 256 general-purpose registers, denoted by the notation R(xx) where
xx is a two-digit hexadecimal number in the range 00-FF, e.g. R(5E), R(C7), and R(19).

At any given time, a certain set of registers are considered active.


** Load instructions

These operators load a value at the top of the stack.

- LD_NUM reg float64    :: floating-point number literal
- LD_STR reg ptr64      :: constant string
- LD_LIST reg ptr64     :: non-empty list
- LD_EMPTY reg ptr64    :: empty list
- LD_TRUE reg           :: true
- LD_FALSE reg          :: false
- LD_NULL reg           :: null
- LD_SYMB reg ptr64     :: symbol
- LD_OBJ reg ptr64      :: load another type of object
- LD_VAR reg ptr64      :: global variable reference (64-bit pointer argument)
- LD_ADDR reg ptr64     :: an address. Could be used for either bytecode or system memory

- LD_REG reg reg        :: load a register value. Args in (dest,source) order

Each of the above also sets the tag bits of the associated register to a unique value based on the
instruction in question, with LD_VAR manually reading the tag of the variable before assigning it
and a pointer to the object to the specified register.


*** Future load instructions

Eventually, it would be cool to add tags for arbitrary-precision floats and integers.


** Object representation

Objects are always passed around as pointers. Variables and registers are tagged to keep track of
object types. Because values are always returned in a register, tags are also preserved.

In addition, the first


** Calling and Stack manipulation

This version of ~fn~ is "stackless", meaning that stack frames are allocated on the heap. The
registers are primarily used for two things: some registers (32?) are reserved for passing
arguments, while the rest are used to hold the results of temporary evaluations.

- CLOSE reg :: create a new closure. This just 


** Alternative: Virtual Memory and Built-in tags

I don't think I'll do this because keeping full 64-bit pointers would make foreign code interop and
low-level code writing much easier.

Suppose we limit ourselves to 56-bit pointers, which is still more than enough memory. Then, we have
8 bytes of the string which we can use as a type tag. We can use a variable-length tagging scheme to
get 62-bit fixed-width integers and if we pick tag 00 (binary) for those, we can use CPU native
integer arithmetic operations. It would also be possible to truncate 64-bit floating point numbers
to 62-bit precision by dropping the two rightmost digit, allowing use of x87 hardware and making
passing around of numbers, etc, much more efficient. A downside of this approach is that it would
give us less than the maximum 256 possible type tags that exist right now.

** Alt. Defn syntax

#+BEGIN_SRC fn
(defn x "Optional doc-string"
  (arg-pattern-1)
    fn-body-1
  (arg-pattern-2)
    fn-body-2
  ...)

i.e.

(defn factorial
  (0) 1
  (n) (* n (factorial (- n 1))))

(defn map
  ([]) )

;; alternative: allow multiple defn's per file
(defn factorial (0) 1)
(defn factorial (n) (* n (factorial (- n 1)))


#+END_SRC
