* Implementation and Bootstraps

  - Everything is implemented in Common Lisp. The only supported implementation
    is SBCL. No particular effort is made to maintain ANSI compliance, although
    most of the code is ANSI anyway.
  - Most of the code is in the FN-IMPL package. This package makes use of some
    features of FN (for instance, the $ reader macro), but we avoid global
    lexical variables, the fn macro, and any functionality that would shadow
    symbols in the CL package.
  - The FN package is a drop-in replacement for the CL package that turns common
    lisp into FN.
  - There will be a standard library one day. It will initially be implemented
    entirely in FN and Common Lisp, but we would like to do a lot of it in C++
    (i.e. threads, networking, matrix operations) eventually.
  - At some point, I will likely reach the limit of what Common Lisp macros can
    easily do, and will need to begin the lengthy undertaking of writing a
    custom VM and interpreter. Beyond that, a dedicated compiler and FFI will
    eventually be desirable, so depending on how far I take this, we may need to
    reimplement the whole damn thing in C++.
  - The benefit to the current implementation of FN is that we can trivially use
    any Common Lisp libraries from FN source, so a crucial precondition to
    reimplementing the core language would be ensuring that it has a very rich
    standard library.


* Schemas and Patterns

  A *schema* is the data structure that describes a data type.

  New data types in FN are usually defined with the defdata operator. Presently
  the defdata operator takes two arguments: a name and an arg list. The arg list
  follows the same syntax as FN arg lists, see the section New Lambda Lists for
  details. This arg list is the argument list for the constructor function,
  which is invoked by (new DATATYPE ARG ...).

  #+BEGIN_SRC common-lisp
    (defdata NAME ARG-LIST) ;=> (defines a data schema)

    (new NAME ARGS) ;=> makes an instance of NAME

    (@ SLOT INSTANCE) ;=> value from SLOT in INSTANCE

    (case OBJ
      (NAME PATTERN-ARG*)
        EXPR
      ...)
    ;; => if OBJ matches the schema, bind the field values to the pattern-args
    ;;    and execute EXPR
  #+END_SRC

  Data classes defined with defdata can be thought of as structs from C. That
  is to say, they are nothing but boxes of named values. The names, which are
  called slots, are the variable names from the arg list.

  #+BEGIN_SRC common-lisp
    (defdata Pair left right) ;=> defines the Pair schema

    (def my-pair (new Pair 1 2)) ;=> make a Pair

    (@ 'left my-pair) ;=> value from SLOT in INSTANCE

    (setf (@ 'right my-pair) 3) ;=> set right to 3

    (case my-pair
      (pair 0 x) (format t "0 and ~s" x)    ;not called (pattern doesn't match)
      (pair 1 x) (format t "1 and ~s" x))   ;will be called
    ;; 1 and 3
    ;;=> NIL
  #+END_SRC  


** What's in a schema?

   As you can see from above examples, schemas provide interfaces to do four
   things:

   - construct new instances of the associated type
   - access slots for such instances
   - set the values of slots
   - perform pattern matching

   A great deal of care is taken to make sure that the interfaces are very clear
   across all four of these.


** Advanced Schemas

   There are already two special schemas in fn: the list and dict schemas. On
   the implementation side of things, these schemas have class general-schema
   rather than the data-schema class used by defdata. Rather than relying on an
   arg-list, general-schema instances contain general functions that accomplish
   each task.

   #+BEGIN_SRC common-lisp
   (case [1 2 3]
     [1 _] (print '_) ;no match (not enough args)
     [1 1 x] (print x) ;no match (second arg mismatch)
     [1 & x] (print x) ;match with rest arg-- prints [2 3]
   )

   (case {:a 'a :b "b"}
     {:a 'b} (print 'b) ;no match (mismatch on :a)
     {:b "b"} (print "b") ;match-- note how not all keys are needed
   )
   #+END_SRC
  
   At some point, we will want to make general-schema functionality available to
   user programs. For now, we're not going to worry about it.


* New lambda lists

  Common Lisp's syntax for argument lists is great because it's unambiguous,
  easy to remember, and powerful. Common Lisp's syntax for argument lists is bad
  because it's verbose, ugly (subjective), and does not run parallel to the
  syntax for function calls.

  The goal with FN's new lambda lists is to give the language a more coherent
  interface than what we currently have in Common Lisp. That is, we would like
  the syntax for argument lists to look more like actual function calls.

  For starters, we simplify the types of arguments that we allow in FN. We now
  only have optional, positional, keyword and rest arguments, with the
  restriction that keyword and rest arguments can not be mixed in the same
  argument list. Next, replace &REST with &. It says enough. Moreover, we forget
  about &OPTIONAL and &KEY-- optional forms are now just lists, and keyword
  forms are actual keywords. This is a taste of our new argument lists:

  #+BEGIN_SRC common-lisp
  (defn func (positional-arg (optional-arg "init") :keyword-arg (keyword-arg "key-init"))
    (function-body))
  #+END_SRC

  And here are some translations from Common Lisp:

  #+BEGIN_SRC common-lisp
  (defun operator (operand0 &rest operands) ...)
  ;; => (in FN)
  (defn operator (operand0 & operands) ...)

  (defun log (x &optional (base 10)) ...)
  ;; => lists replace &optional
  (defn log (x (base 10)) ...)

  (defun sort (seq &key (test #'< test-p) (ascending t)) ...)
  ;; => keyword arguments replace &key
  (defn sort (seq :test (test #'<) :ascending (ascending t)) ...)
  #+END_SRC

  This also gives us the ability to define non-optional keyword arguments via
  the syntax (:keyword-arg keyword-arg) (where the arg is a symbol, not a list).

  #+BEGIN_SRC common-lisp
  ;; define a function requiring a keyword argument
  (defn func (:req-key req-key :opt-key (opt-key "default")) 
    (function-body))

  (func) ;=> error (needs req-key)
  (func :req-key 6) ;=> okay (opt-key = "default")
  (func :opt-key 9) ;=> error (needs req-key)
  (func :req-key 6 :opt-key 9) ;=> okay
  #+END_SRC

  These non-optional keywords are especially useful when defining new data types
  via defdata.


* Lexical scope

  I implemented global lexical scope in Common Lisp so we can have it in fn.

  
* Misc functions/macros

  - defschema
  - with-fields, with-fields*
  - match
  - dict
  - new
  - @
  - fold, map, filter, zip


* design ideas

  - parentheses denote code objects. quote and backquote return code objects
    that can be used by the program. Unquoted code is evaluated. Code objects
    are made out of primitive types, symbols, and conses.
  - square brackets are for lists (and consequently trees). Lists are singley
    linked in classic lisp fashion. We use the ampersand (&) instead of the dot
    for inline conses.
  - rejected idea (don't repeat this mistake): & is a function so (& a b c) :=
    [a b & c].
  - make objects with the keyword NEW. Schemas decide their own constructor
    parameters
  - Every schema has a corresponding pattern matcher
  - When looking up an object's schema, we will use the class name of the object
    as the key for a hash table. This is to make the lookup as fast as possible.


* Experimental Zone

  This is where I'm gonna put some wild ideas that I'm not sure about.

** schemas with custom internal data structures

   eee

   
** protocols (polymorphism)

   I really like how protocols work in SML/how type classes work in Haskell.
   However, these implementations are indelibly tied to the static type system.
   Here's an example: suppose we wanted to define a sequence type class in
   Haskell. We want our sequence types to satisfy two requirements: we can
   create an iterator from any sequence, and we can get an empty version of that
   sequence. We can define our iterator and sequence typeclasses like so

   #+BEGIN_SRC haskell
   class Iterator a where
       hasNext :: a -> Bool
       iterNext :: a -> a
       iterGet :: a -> b

   class Sequence a where
       empty :: a
       iterator :: Iterator b => a -> b
       conc :: a -> a -> a

   -- example instance
   data ListIt = ListIt lst
   instance Iterator ListIt where
     hasNext (ListIt lst) = lst == []
     iterNext (ListIt lst) = ListIt (tail lst)
     iterGet (ListIt lst) = head lst

   instance Sequence [a] where
     empty = []
     iterator x = ListIt x
     conc x y = x ++ y

   #+END_SRC

   Don't try running this code. I haven't written Haskell in a while. Even so,
   this example is instructive, as it reveals some of the key features of an
   effective ADT protocol system.

   It is immediately clear that we want two new special forms to implement
   protocols. We will define protocols with defproto, and create implementations
   with defimpl. In addition, we will need to define some sort of symbol which
   corresponds to the designated type (in the Haskell example, it's the variable
   a).

   Also, we can see that the empty method is not a function. Rather, it works
   like a variable, with the type system doing the heavy lifting-- in Haskell's
   case, the compiler decides which version of empty to use based on the type
   expected in the code. Haskell is pretty cool.

   To emulate this behavior in FN, we would like a way to define a function
   (empty TYPE) which takes the type name as a symbol. E.g. (empty 'list) =>
   NIL. In addition, we will need a way to specify methods that accept arguments
   of the given type.

   I have a solution which I believe kills two birds with one stone.

 
** unified definition

   First off, let's not kid ourselves: DEFPARAMETER is too long of a name.
   DEFVAR is not so bad, but usually we want DEFPARAMETER behavior, rather than
   DEFVAR behavior.
   
   Currently, I've decided to use DEF for declarations, SET for updates, CONST
   for constants, and DEFN for functions.

   #+BEGIN_SRC common-lisp
   (defparameter x 6)
   ;; => (in FN)
   (def x 6)

   (defconstant pi 3.14)
   ;; =>
   (const pi 3.14)

   (defun log (x &optional (base 10))
     ...)
   ;; =>
   (defn log (x (base 10))
     ...)
   ;; or, equivalently, (but not until the future)
   (def log
     (fn (x (base 10))
       ...))
   #+END_SRC


** function options

   Functions look like this:

   (fn (args) body)

   We would like to customize function behavior. If the first argument of the
   function body is a dict form (denoted below with braces), and the body has
   length > 1, then we will use that dictionary as the function options:

   (fn (args)
     {:option-name option-value ...}
     body)

   Some ideas for options are:

   - :type, :optimize, :ignore, ignoreable :: replace DECLARE forms
   - :inline BOOL :: whether to inline this function
   - :curry N :: automatically curry up the first N arguments. Or, if N is true,
                 then curry all positional arguments (default: false, eqv. 0)
   - :memo BOOL :: memoize the function if true (default: false)
   - :doc STR :: docstring (only in definitions)
   - :arg-doc LIST :: argument documentation (only in definitions)


** Local definitions


* Immediate future


