* Introduction

fn is a programming language in the Lisp family. It will feature a robust and streamlined object
system, an intuitive module-based approach to code organization, powerful metaprogramming
facilities, and a variety of quality of life features that aid in writing especially concise code
without sacrificing clarity.

** fn compared to other dialects of Lisp

Compared to most dialects of Lisp, fn has a small number of special forms, several new syntactic
conveniences, and a strong focus on its native object system. The object system strives to avoid
several problems with CLOS, namely its feeling tacked-on to the rest of the language (because it
was) and being rather verbose.

In addition, fn code is homoiconic like Common Lisp, allowing writing of macros in the traditional
Lisp way, which I greatly prefer to the hygienic macros and templates of e.g. Racket or Scheme.
However, unlike Common Lisp, where even "properly-written" macros can break in the case of an
esoteric name collision, fn allows functions and variables to be looked up during macroexpansion in
order to avoid such issues. Thus the goals of hygiene may be achieved without resorting to using
special syntax objects or creating a pattern-based DSL.



** Implementation notes

- Everything is implemented in Common Lisp. The only supported implementation is SBCL. No particular
  effort is made to maintain ANSI compliance, although most of the code is ANSI anyway.
- This code is only tested on a handful of my personal computers, all of which run Arch Linux.
- I am currently in the process of rewriting fn. The previous version, which was nearly a feature
  complete version 0, was built as a layer on top of Common Lisp, using the Common Lisp reader and
  macros to implement almost all of its features. This new version will be a proper interpreter.


** Inspirations/Credit

fn's design was strongly inspired by Clojure, Python, Common Lisp, and Haskell. All four of those
are great programming languages. Honestly, if I could get a full version of Clojure that didn't need
the JVM or the CLR, I might not have bothered making a new programming language, although I really
don't care for pure functionality as much as Rich Hickey. In that respect I prefer Common Lisp. When
you get down to it, Common Lisp can be massaged into a very good language and development
environment using FOSS tools and libraries such as Quicklisp, Alexandria, and Emacs+SLIME. Common
Lisp can be further customized to the extent that even built-in special forms and syntax can be
overwritten, which is what I used to prototype early versions of fn. However, I have two serious
problems with Common Lisp. Firstly, it is too much work to configure a Common Lisp environment
compared to, say, Python or Haskell, which are essentially ready to go out of the box. While this
can be overcome by patience, a more significant problem is that since Common Lisp is built out of
so many different pieces, it feels very inconsistent in a way that is often jarring. Thus, I set out
to build a programming language just, for myself, that took the good parts of Common Lisp and added
some modern features.


* Modules and Name Resolution

** Definition order

In fn, loading source files behaves as is they are evaluated one expression at a time from beginning
to end. Function and variable lookups may be performed at runtime, so a function may use a variable
or another function whose definition appears later in the file.

The same rules generally apply to macros, but with some gotchas. Macros may be defined in the same
file they are used in, but must be appear (lexically) before any uses. If a macro uses a function to
create its expansion, then that function must be defined before the macro is first expanded (duh)


** Modules

Right now, modules have a 1-to-1 correlation with fn source files. To import a file, you use import
with a symbol corresponding to the file name, without any extension.

#+BEGIN_SRC fn
;; imports from file "x.fn" and binds the module as x
(import x)
;; imports from file "x.fn" and binds the module as y
(import x 'as y)
;; imports from file "x.fn" and binds all variables locally
(import x 'as _)
#+END_SRC

Modules are first class objects and their variables may be accessed using ~get~ or dot syntax.

#+BEGIN_SRC fn
;; file my-module.fn
(def my-var 26)

;; file example-a.fn
(import my-module)
my-module.my-var ;=> 26

;; file example-b.fn
(import my-module 'as mod)
mod.my-var ;=> 26

;; file example-c.fn
(import my-module 'as _)
my-var ;=> 26
#+END_SRC


*** Accessing modules without imports

The function ~(find-module sym)~ can be used to search for modules at runtime (the argument ~sym~ is
evaluated). Additionally, the syntax ~#.sym~ (eqv. to ~(get # 'sym~)) is available as a shorthand for
module lookups.


*** Implementation note: modules, macros, and dynamic vars

In Common Lisp, importing a macro means importing a symbol from another package. E.g. I import ~LOOP~
from ~CL~ and now every time I type ~loop~ it gets silently converted to ~CL:LOOP~. This allows a
one-to-one correspondence between macros and the symbols that represent them. At evaluation time, we
are guaranteed that the operator for a macro expression will always be a symbol, and its just a
matter of looking in that symbol's macro binding slot. In ~fn~, we no longer have the guarantee that
the operator is a symbol, and we have first-class module objects instead of packages, so we need to
take a more sophisticated approach.

The interpreter will internally maintain a list of which symbols (if any) are bound to modules.
Then, to do macro expansion on a list, we perform two checks: first, whether it's a symbol bound to
a macro in the current module (duh). If not, we check next whether the operator is a ~get~ expression.
If it is, and its first argument is a symbol referencing an imported module, then we can check that
module for macro bindings as well. This allows painless use of macros from other modules.


*** Future extension: ~__modules.fn~

In the future, a file named ~__modules.fn~ may be added to a source directory in order to define
modules that don't correspond directly to files and to modify the search path on a per-project
basis. In addition, it will be possible to automatically define wrapper modules that import all
their variables from submodules in order to create cleaner interfaces.


** Dynamic variables

In fn, dynamic variables may be created using ~defvar*~. In keeping with lisp tradition, we
recommend naming dynamic variables with earmuffs. (No ~def*~ form is included, because all dynamic
variables need to be resolved, well, dynamically, so they might as well be mutable).

#+BEGIN_SRC fn
(defvar* *name* initial-value)
#+END_SRC

This declares ~*name*~ to be a dynamic variable. Dynamic variables may be rebound with ~let~.

#+BEGIN_SRC fn
(defvar *special-x* 27)

(def (get-value) *special-x*)

(get-value) ;=> 27
(let (*special-x* 420)
  (get-value) ;=> 420
  )
(get-value) ;=>27
#+END_SRC

IMPORTANT NOTE:* Unlike in other dialects of lisp, special variables must be declared before they
are treated as special. Uses prior to that point will be treated as normal lexical variables.
Example:

#+BEGIN_SRC fn
(def (call-with-square-0 fun x)
  (let (sq (* x x))
    (fun sq)))

(defvar* sq 16)

(def (call-with-square-1 fun x)
  (let (sq (* x x))
    (fun sq)))

(def (get-sq _) sq)

;; call-with-square-0 treats sq as a normal lexical variable because it was defined before sq was 
;; declared dynamic.
(call-with-square-0 get-sq 6) ;=>16

;; call-with-square-1 treats sq as a dynamic variable
(call-with-square-0 get-sq 6) ;=>36

#+END_SRC


* Functions

There are two special operators that create functions: ~fn~ and ~dollar-fn~. The latter is usually
written using dollar-sign syntax. The expression ~$(function-body)~ expands to ~(dollar-fn
(function-body))~.

#+BEGIN_SRC fn
  ;; syntax for fn is
  (fn (<parameters>) <body>)

  ;; there are three kinds of parameters recognized by fn: positional, keyword, and variadic.
  ;; Positional params are denoted by plain symbols and keyword params by quoted symbols. Variadic
  ;; parameters are defined by using the special symbol & followed by a symbol indicating the name of
  ;; the variable.

  ;; function that takes two positional arguments and sums their reciprocals
  (def sum-inv 
    (fn (x y)
      (+ (/ 1 x) (/ 1 y))))
  (sum-inv 0.5 0.2) ;; => 7

  ;; function that takes one positional argument and two keyword arguments. This function will 
  ;; apply the function if-num if v is a number, otherwise it will apply 'otherwise.
  (def apply-if-num
    (fn (v 'if-num 'if-not)
      (if (num? v)
          (if-num v)
          (if-not v))))
  ;; to call functions with keyword arguments, simply put the quoted symbols in the argument list
  (apply-if-num "hello" 'if-num String 'if-not println) ;; prints "hello"
  ;; keyword arguments may be provided in any order
  (apply-if-num 2 'if-not println 'if-num String) ;; => "2"

  ;; keyword and positional parameters can be made optional by putting them in parentheses followed 
  ;; by a default expression. Required parameters may not succeed optional ones.
  (def increment (num (by 1))
    (+ num by))
  (increment 17) ; => 18 (uses default value for by)
  (increment 17 2); => 18

  ;; variadic arguments must come last in an argument list.
  (def string-sum (& numbers)
    (String (apply + numbers)))

#+END_SRC

*** Wildcard parameters

Positional parameters using the wildcard symbol "_" are treated specially. Such parameters do not
cause any variables to be bound in the function body, i.e. the argument in the corresponding
position is ignored. These may also be used as optional arguments, although a dummy default value
must still be provided, e.g. ~(_ null)~


*** Variadic arguments and keywords

When a function accepts both keywords and variadic arguments, all the variadic arguments must be
alternating symbol and value pairs, just like normal keyword arguments. This behavior is very
similar to the behavior of combining ~&REST~ and ~&ALLOW-OTHER-KEYS~ in Common Lisp. The one difference
is that the property list bound to the variadic argument will not contain any of the explicitly
specified keyword parameters. That is:

#+BEGIN_SRC fn
(def (fun 'key1 & other-keys)
  other-keys)

;; other-keys will not contain the value for 'key1
(fun 'key1 4 'key2 6 'key3 8)
;; => ('key2 6 'key3 8)

#+END_SRC

Functions which accept both variadic arguments and keywords have argument checking done to make that
the keyword arguments form a plist. To get argument checking without having any explicit keyword
arguments, include "'_" (quote underscore) in the parameter list.

#+BEGIN_SRC fn
;; this function accepts any arguments
(def (fun1 & args)
  args)
;; so this is fine
(fun1 'key 2 3.14159 "hello" 'key2)

;; this function only accepts arguments that form a proper plist
(def (fun2 '_ & args)
  args)
;; this is an error
(fun2 'key 2 3.14159 "hello" 'key2)
;; but this is fine
(fun2 'key 2 'key2 "hello")

#+END_SRC


* Classes and Methods

fn is an object-oriented programming language. Every value in fn is an object, and every object is
an instance of some class, which describes the object's structure. Polymorphism is provided via
methods, which are callable objects that perform different actions based upon the classes of their
arguments.

** Anatomy of an Object

Objects are key-value stores where the keys are symbols called the *fields* of the object and the
values are arbitrary. In addition, every object has a *class* which may be accessed using the built-in
~class-of~ operator. The class contains a list the object's fields as well as a symbol representing
the class's name.


** Classes

Classes are defined using the ~defclass~ operator, which creates a global variable holding a ~Class~
object. Class objects are created based upon a parameter list. This parameter list serves two
functions. First, the variables in the parameter list denote the fields of the class. Second, the
constructor for the class(, invoked by calling the class as an object,) uses the parameter list to
process its arguments.

By convention, type names begin with capital letters.

#+BEGIN_SRC fn
;; class definition
(defclass (Class-Name & params))

;; to invoke the constructor, use call the class like a function
(Class-Name & args)

;; Access fields directly
(get-field obj 'field)
(set (get-field obj 'field) new-value)

;; Access fields via the generic accessors
(get obj 'field)
(set (get obj 'field) new-value)
;; or, equivalently,
obj.field
(set obj.field new-value)
;; this dot notation is preferred wherever possible

;; we can even get fields from the Class itself
(get Class-Name 'fields) ;=> params
(get Class-Name 'name) ;=> 'Class-Name


;; if Class were defined with defclass: (note: it wasn't and there's no constructor)
(defclass (Class name fields constructor))
(class-of class)
#+END_SRC

*** Future features

Options should allow customization of the object's internal representation, constructor, and fields.
E.g. fields may be marked mutable or have type restrictions applied.


** Polymorphism via Methods

fn provides polymorphism in the form of methods. fn's methods support multiple dispatch (i.e. they
are multimethods). The syntax is demonstrated below.

#+BEGIN_SRC fn
;; To define a multimethod, you must specify its name, a list of one or more dispatch parameters,
;; and a parameter list containing all the dispatch parameters.

(defmethod ((<name> <dispatch-params>) <params>))

;; Methods are implemented using def. Syntax is very similar to function definition except that
;; the name of the method and the dispatch types must also be specified.
(def ((<name> <dispatch-classes>) <params>)
  <implementation-body>)

;;; EXAMPLE: the call method (used to treat arbitrary objects as functions)
;; call does dispatch on the argument obj
(defmethod ((call obj) obj & args))

;; implementation of call on classes
(def ((call Class) class & args)
  (apply class.constructor args))

;;; EXAMPLE: the mul method used to extend multiplication.
;; mul does multiple dispatch on the arguments l and r
(defmethod ((mul l r) l r))

;; implement methods using def. Parameter names may be changed.
(def ((mul Num String) ct str)
  (loop (i res) (ct "")
    (if (= i 0)
        res
        (recur (- i 1)
               (append res str)))))

(def ((mul String Num) str ct)
  ;; simply flip the arguments 
  (mul ct str))

#+END_SRC

*** Implementation

Dispatch is done using hash tables. The keys are lists of Class objects.


** Built-in classes

The following classes are built into fn.

*Atomic types*
- Symbol :: symbol
- Bool :: boolean denoted ~true~ or ~false~
- Null :: unassigned value denoted ~null~
- Num :: 64-bit floating-point number

*Structure types*
- Class :: the type of types
- List :: singley-linked list
- String :: character string

(Hash-)tables, arrays, foreign data structures and byte arrays are planned for the future.


* Comprehensive language description

This section completely (and formal-ish-ly) describes fn as it is now. It is a work in progress, but
it's completion is a priority.

** Syntax
*** Literals

*** Symbols

*** Lists

*** Other syntax


** Special operators

Below is a complete list of fn's special operators. Operators marked done are fully documented below
and implemented in the interpreter

*** DONE ~apply~

#+BEGIN_SRC fn
;;; syntax - apply
(apply <fun> <args*> <arg-list>)
;;; where
;; <fun> is a function
;; <args> 0 or more arguments to be passed to <fun>
;; <arg-list> a list of arguments to be passed to <fun>
#+END_SRC

~apply~ calls a function with elements of the provided list as arguments. If <args*> are specified
before <arg-list> then those arguments are prepended to the arg-list before calling.

*** TODO ~case~

~case~ behavior is not yet specified.

*** DONE ~class-of~

#+BEGIN_SRC fn
;;; syntax - class-of
(class-of <obj>)
;;; where
;; <obj> is an arbitrary object
#+END_SRC

~class-of~ gets the class of an object.

*** DONE ~def~

#+BEGIN_SRC fn
;;; syntax - def
(def <var> <value>)                          ; var def
(def (<var> <params*>) <body*>)              ; function def
(def ((<method> <types*>) <params>) <body*>) ; method def
;;; where
;; <var> is an unbound symbol
;; <value> is an expression
;; <params*> is a parameter list
;; <types*> is a non-empty list of symbols naming classes
;; <body*> is a function body
;; <method> is a symbol naming a global method
#+END_SRC

~def~ has three forms that each perform a different action. The first form defines an immutable global
variable with the specified value. The second form creates a function named <var> with the provided
params and body. The third form defines a method implementation of <method> on the provided types.

*** TODO ~defclass~

*** TODO ~defvar~

*** TODO ~do~

*** TODO ~dollar-fn~

*** TODO ~fn~

*** TODO ~get~

*** TODO ~get-field~

*** TODO ~if~

*** TODO ~import~

*** TODO ~let~

*** TODO ~quasiquote~

*** TODO ~quote~

*** TODO ~set~

*** TODO ~unquote~

*** TODO ~unquote-splice~


** Built-in values

*** Classes

*** Functions

*** Methods

*** Macros


* Misc Notes and Ideas

This section is a bunch of garbage to help me remember things. I don't recommend trying to read
this.

** Standard library

Math module:

- floor, ceil, round, frac (a.k.a fractional part)
- sin, cos, tan, sinh, cosh, tanh, asin, acos, atan
- exp, pow, log
- +, -, *, /, mod
- with-modulus (macro, locally rebinds +, -, *, and pow exprs to do modular arithmetic)


Sequence library:

- (method) append
- (method) get-iter
- (class) Iter
- (class) Lazy-List
- map, foldl, foldr
- (replace subseq new-place seq)
- (split subseq seq)



** Version 0 Spec

If anyone other than me ever tries to read this, I'm sorry. This is a "complete" specification of
version 0 of the fn programming language (i.e. complete enough for me, the language designer, to
remember the decisions I've made so far).

*** Flow control

- cond
- do
- if
- let

*if* works as it always does and *do* works like ~PROGN~ does in Common Lisp or ~begin~ in Scheme.

*cond* has its syntax changed so omit the second level of parentheses. Instead, it takes an
alternating series of tests and results, and automatically groups them into pairs.

#+BEGIN_SRC fn
  ;; syntax
  (cond
    test0
      result0
    test1
      result1)

  ;; example. returns "fizz" if x is a multiple of 3, "buzz" if it's a multiple of 5, "fizzbuzz" if
  ;; it's both, and x as a string if it's neither.
  (defn foo (x)
    (cond
      (= (mod x 15) 0) "fizzbuzz"
      (= (mod x 5) 0) "buzz"
      (= (mod x 3) 0) "fizz")
      (true (String x)))
#+END_SRC


~let~ has been modified in a similar way, doing away with the second layer of parentheses in the
binding specs

#+BEGIN_SRC fn
  (let (a 2
        b 3
        c 4)
    (+ a b c))
  ;; => 9

  ;; let behaves like scheme's letrec
  (defn reverse-map (f lst)
    (let (iter
           (fn (acc src)
             (if src
                 (iter (cons (f src.hd) acc)
                       src.tl)
                 acc)))
      (iter [] lst)))
                   
#+END_SRC


*** Type System 

Version 0 will implement the complete type system as described in Type System at the top level of
this document.


*** Macros

#+BEGIN_SRC fn
;; define a macro
(defmacro NAME (ARG-LIST...)
  "Doc string"
  MACRO-BODY)
#+END_SRC

Macros work in the usual lisp way, and they are unsanitary. Macro functions may return function
objects as part of their outputs. This is encouraged as a way to prevent lexical variable
definitions from colliding with global module or function names.

*Note:* In the future, some facility e.g. a ~global~ special form may be introduced which allows global
variables to be accessed from macros without needing to include them as literals. Such a form would
possibly return a pointer object that unambiguous denoted the variable being referenced.


*** Syntax

Syntax is standard lisp parenthesized prefix notation. The following are all the special syntax
characters:

$()[]{}\;"',.

all other non-whitespace characters are symbol constituents, that is, they are parsed as atoms, i.e.
as symbols or numbers.


**** Delimiters

In typical lisp fashion, () are the delimiters denoting lists. In addition, [] and {} are matched
delimiters for reading lists and dicts. In fact, they are converted by the reader.

[a b c] -> (List a b c),
and
{:a 0 :b 1} -> (Dict :a 0 :b 1)

Also, "" reads UTF-8 strings. It uses C/C++ escape sequences because those are better than the lisp
ones and support Unicodes. Get over it.


**** Comments

There are no multi-line comments in fn. Only line-end comments, started by semicolons, are
supported.


**** Dollar sign

See function creation.


**** Quotation

Normal quote works as it usually does in Lisp. Quasiquote works the same but lacks a destructive
splice.


**** Escaping

Escaping is when a backslash (/) character is placed in front of another character, thereby turning it
into a symbol constituent.. Any character can be escaped in any context except for within a string, (where string
escaping rules apply instead).


**** Dot notation

See Generic Accessors


** Important idea: global pointers

I think it would be very useful to introduce a "pointer" data type (a better name might be GUID,
place, or address) which is simply an unambiguous reference to some global variable (possibly also
local?). GUID syntax could start with #G (or something) and would be very much analogous to symbols
in Common Lisp, in that GUIDs, like CL's symbols, would be standalone places to store objects. This
also allows an elegant alternative to gensyms, i.e. randomly-generated, disposable places.


** Future Features

Once I've implemented everything up to version 0, I'm going to get to work on a module system as
well as a way to sanitize macros where necessary (probably via some sort of GUID for global
variables). That will be version 0.1. From there, the next steps will be to add multithreading and
FFI and to otherwise flesh out the standard library, which eventually will lead me to version 0.2
(and possibly 0.3 depending on how I break up the work). I will not increment to version 1.0 until
the interpreter is rewritten in C++. Further goals include implementing JIT compilation using LLVM,
adding a scientific computing/linear algebra library, and adding networking and IPC modules.



** Version 0 lexer tokens

(delimiters)
left-paren, right-paren, left-bracket, right-bracket, left-brace, right-brace

(unary operators)
dollar-sign, quote, backtick, comma, comma-splice

(binary operator)
dot

(literals)
number, string, symbol

comments

eof


** Version 0 grammar

#+BEGIN_SRC haskell
program -> expr* EOF
expr    -> constant
         | compound
         | unary
         | dot

constant -> STRING
          | NUMBER

compound -> paren
          | bracket
          | brace
paren    -> "(" expr* ")"
bracket  -> "[" expr* "]"
brace    -> "{" expr* "}"

unary      -> quote
            | quasiquote
            | unquote
            | unquote-splicing
            | dollar
quot       -> "'" expr
quasiquot  -> "`" expr
unquot     -> "," expr
unquot-splice -> ",@" expr
dollar     -> "$(" expr* ")"
            | "$[" expr* "]"
            | "${" expr* "}"
            | "$" quasiquote

dot -> SYMBOL "." SYMBOL
     | dot "." SYMBOL
#+END_SRC

#+BEGIN_SRC common-lisp
  (defun token-is? (tok kind)
    (eq (token-kind tok) kind))

  (make-parser
   ;; first form is grammar
   ((program -> (* expr) @eof)
    (expr -> constant / group / unary / dollar / dot)

    (constant -> @string / @number)

    (group -> paren / bracket / brace)
    (paren -> @left-paren (* expr) @right-paren)
    (bracket -> @left-bracket (* expr) @right-bracket)
    (brace -> @left-brace (* expr) @right-brace)

    (unary -> quot / quasiquot / unquot / unquot-splicing)
    (quot -> @quot expr)
    (quasiquot -> @backtick expr)
    (unquot -> @comma expr)
    (unquot-splice -> @comma-splice expr)

    (dollar -> @dollar-paren (* expr) @right-paren
            / @dollar-bracket (* expr) @right-bracket
            / @dollar-brace (* expr) @right-brace
            / @dollar-backtick expr)

    (dot -> var / dot @dot var)
    (var -> @symbol))

   ;; remaining forms are callbacks for nonterminals. Whenever a reduce is performed, the callback
   ;; corresponding to the generated nonterminal is invoked with a single argument, a list of the
   ;; POBJs used to make this pattern.
   (constant #'constant-fun)
   (dot #'dot-fun)
   (var #'var-fun)
   )

#+END_SRC


** Bytecode version 0

All instructions are 1 byte long. The first machine will be a register machine, because it's going
to be a register machine eventually anyway.


** Registers and calling conventions

Each general-purpose register has two parts: an 8-bit tag and a 64-bit value. The tag indicates the
type of the data. Each thread has 256 general-purpose registers, denoted by the notation R(xx) where
xx is a two-digit hexadecimal number in the range 00-FF, e.g. R(5E), R(C7), and R(19).

At any given time, a certain set of registers are considered active.


** Load instructions

These operators load a value at the top of the stack.

- LD_NUM reg float64    :: floating-point number literal
- LD_STR reg ptr64      :: constant string
- LD_LIST reg ptr64     :: non-empty list
- LD_EMPTY reg ptr64    :: empty list
- LD_TRUE reg           :: true
- LD_FALSE reg          :: false
- LD_NULL reg           :: null
- LD_SYMB reg ptr64     :: symbol
- LD_OBJ reg ptr64      :: load another type of object
- LD_VAR reg ptr64      :: global variable reference (64-bit pointer argument)
- LD_ADDR reg ptr64     :: an address. Could be used for either bytecode or system memory

- LD_REG reg reg        :: load a register value. Args in (dest,source) order

Each of the above also sets the tag bits of the associated register to a unique value based on the
instruction in question, with LD_VAR manually reading the tag of the variable before assigning it
and a pointer to the object to the specified register.


*** Future load instructions

Eventually, it would be cool to add tags for arbitrary-precision floats and integers.


** Object representation

Objects are always passed around as pointers. Variables and registers are tagged to keep track of
object types. Because values are always returned in a register, tags are also preserved.

In addition, the first


** Calling and Stack manipulation

This version of ~fn~ is "stackless", meaning that stack frames are allocated on the heap. The
registers are primarily used for two things: some registers (32?) are reserved for passing
arguments, while the rest are used to hold the results of temporary evaluations.

- CLOSE reg :: create a new closure. This just 


** Alternative: Virtual Memory and Built-in tags

I don't think I'll do this because keeping full 64-bit pointers would make foreign code interop and
low-level code writing much easier.

Suppose we limit ourselves to 56-bit pointers, which is still more than enough memory. Then, we have
8 bytes of the string which we can use as a type tag. We can use a variable-length tagging scheme to
get 62-bit fixed-width integers and if we pick tag 00 (binary) for those, we can use CPU native
integer arithmetic operations. It would also be possible to truncate 64-bit floating point numbers
to 62-bit precision by dropping the two rightmost digit, allowing use of x87 hardware and making
passing around of numbers, etc, much more efficient. A downside of this approach is that it would
give us less than the maximum 256 possible type tags that exist right now.


** Alt. Defn syntax

#+BEGIN_SRC fn
(defn x "Optional doc-string"
  (arg-pattern-1)
    fn-body-1
  (arg-pattern-2)
    fn-body-2
  ...)

i.e.

(defn factorial
  (0) 1
  (n) (* n (factorial (- n 1))))

(defn map
  ([]) )

;; alternative: allow multiple defn's per file
(defn factorial (0) 1)
(defn factorial (n) (* n (factorial (- n 1)))


#+END_SRC


