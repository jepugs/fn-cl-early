* Implementation and Bootstraps

  - Everything is implemented in Common Lisp. The only supported implementation
    is SBCL. No particular effort is made to maintain ANSI compliance, although
    most of the code is ANSI anyway.
  - Most of the code is in the FN-IMPL package. This package makes use of some
    features of FN (for instance, the $ reader macro), but we avoid shadowing
    any variables from the CL package.
  - The FN package is a drop-in replacement for the CL package that turns common
    lisp into FN.
  - There will be a standard library one day. It will initially be implemented
    entirely in FN and Common Lisp, but we would like to do a lot of it in C++
    (i.e. threads, networking, matrix operations) eventually.
  - At some point, I will likely reach the limit of what Common Lisp macros can
    easily do, and will need to begin the lengthy undertaking of writing a
    custom VM and interpreter. Beyond that, a dedicated compiler and FFI will
    eventually be desirable, so depending on how far I take this, we may need to
    reimplement the whole damn thing in C++.
  - The benefit to the current implementation of FN is that we can trivially use
    any Common Lisp libraries from FN source, so a crucial precondition to
    reimplementing the core language would be ensuring that it has a very rich
    standard library.


* Schemas and Patterns

  Schemas describe the shape of data.

  #+BEGIN_SRC common-lisp
  (defdata NAME &REST SLOT) ; => (defines a data schema)

  (new NAME &REST SLOT-VALUES) ; => instance of NAME

  (@ INSTANCE SLOT) ; => value of FIELD in INSTANCE

  (match OBJ
    (NAME &REST PATTERN-ARGS)
      EXPR
    ...)
  ;; => if OBJ matches the schema, bind the field values to VARS and execute 
  ;;    EXPR
  #+END_SRC


** What is a schema?

   Schemas are an abstract way to think about data structures. Every schema
   somehow defines the following facilities:

   - a constructor, which is invoked by the NEW keyword and builds an instance
     of the given schema
   - accessors (getters & setters) for the slots (if any) contained in the
     schema
   - pattern matching for objects fitting this schema

   Every schema doesn't necessarily need to implement all of these facilities--
   for instance, we have pattern-schemas which raise an error if you attempt to
   construct an instance of them, and data-schemas are immutable by default and
   raise an error if you try to use a setter. (Note: we might want to provide
   force-set! to ignore these errors).


** Advanced Schemas

   Schemas are implemented in such a way that construction, access, and
   destructuring (i.e. pattern matching) can all be handled independently by
   general functions. This isn't especially useful in general, but it allows
   definition of special behaviors i.e. for dicts and linked lists.


** Schema Implementation

   Schemas are implemented via the schema class. Pertinent slots are:

   - name :: a symbol representing the name of the schema. This is used to
             identify it in constructors, accessors, and patterns and it *must*
             be unique in the schema table
   - data-class :: the class associated with the schema. This is used to
                   match schemas to instance objects, so it must be unique.
   - construct :: a function (f ARGS) that returns an instance of this Schema
   - access :: a function (f INSTANCE FIELD-NAME) that gets fields from the
               object
   - destruct :: a function (f PATTERN-ARGS OBJ) that returns a bindings object
                 or NIL


** Rethinking data schemas: Addressing and inheritance

   We think of objects as being labelled boxes which may contain other objects.
   To take objects out of box, we need some sort of addressing scheme. The
   current approach uses named positional arguments to do this. This gives us
   two ways to take values out of the box:

   - using match with positional arguments, i.e. (match x (pair a _) a) would
     bind a to the first field of our hypothetical pair object.
   - using @ with the name of an argument. Suppose we name the fields of pair
     left and right. Then we can get the variable above using (@ 'left 

   The current implementation of general-schema is perfect, because it gives us
   control over the arguments for the constructor, the fields accepted by the
   accessors, and the pattern matching independently. What we need to rethink is
   the implementation for normal schemas (which we will refer to as data schemas
   from now on).

   First of all, given the flexibility of general-schema, we don't have to worry
   about covering all possible edge cases for data schemas. We can, for
   instance, say that all fields are addressable by keywords, which means that
   no two symbols in the field list can have the same name (even if they're in
   different packages). In fact, this gives us the very cool opportunity to do
   something like this: (:key obj) === (@ key obj). Since keywords can't have
   values bound to them, we might as well let them function as accessors.

   So far we haven't changed anything that matters to pattern matching. The
   problem, however, comes in when we have data schemas with many fields. e.g.

   #+BEGIN_SRC common-lisp
   (defdata contact
     whole-name
     family-name
     preferred-name
     aliases
     birthdate
     height
     weight
     eye-color
     hair-color
     nationality)
   #+END_SRC

   Suppose we want to match people whose eye-color is :blue. Then we would have
   to do something like

   #+BEGIN_SRC common-lisp
   (match peep
     (contact _ _ _ _ _ _ _ :blue _ _) (do-something peep))
   #+END_SRC

   What a pain in the ass. So, we'll definitely want something like this
   instead:

   #+BEGIN_SRC common-lisp
   (match peep
     (contact :eye-color :blue) (do-something peep))
   #+END_SRC

   This takes advantage of the fact schemas (and consequently patterns) can't
   have keywords as names.

   Unfortunately, using the syntax above, we can't have it both ways.


** types of schemas

   We have general-schemas, which give you independent control of construction,
   accessors, and pattern matching (to allow users to define them in software,
   they will also need to be able to specify one or more private fields that
   contain the data). We have data-schemas, which are a record type. We will
   also introduce pattern-schemas, which are patterns.


** pattern schemas

   - (satisfies FUNCTION) which is true if (FUNCTION x) is
   true, x is the object
   - (type TYPE) is true if (is-subtype (type-of x) TYPE) is true


* New lambda lists

  Here's what we have in Common Lisp:

  #+BEGIN_SRC common-lisp
  (defun func (POSITIONAL-ARGS SPECIAL-ARG*) ...)
  #+END_SRC

  with

  - POSITIONAL-ARGS ::= SYMBOL*
  - SPECIAL-ARG ::= &rest SYMBOL | &whole SYMBOL | &body SYMBOL |
                    &key OPT-ARG* | &optional OPT-ARG*
  - OPT-ARG ::= SYMBOL | (SYMBOL VALUE)
 
  For now, we're going to completely nix &whole and &body. We will replace &rest
  directly with the symbol & (the ampersand by itself, like in Clojure). We
  replace &optional and &key with parenthesized forms as seen in the example
  below.

  #+BEGIN_SRC common-lisp
  (defun operator (operand0 &rest operands) ...)
  ;; => (in FN)
  (defun operator (operand0 & operands) ...)

  (defun log (x &optional (base 10)) ...)
  ;; => lists starting w/ non-keyword symbols replace &optional
  (defun log (x (base 10)) ...)

  (defun sort (seq &key (test #'< test-p) (ascending t)) ...)
  ;; => lists starting with keywords replace &key
  (defun sort (seq (:test #'< test-p) (:ascending t)) ...)
  #+END_SRC

  *Rationale:* I personally think argument lists in Common Lisp are too verbose
  and rather ugly because of it. By cutting out all of the &-symbols (except the
  rather intuitive & itself), the argument lists are shorter if nothing else. As
  a matter of taste, it also seems more LISP-y.

  *Key arg packages: a semantic gotcha:* In CL it is generally legal to use
  variables in an external package as function arguments. Our implementation of
  keyword arguments means that keyword symbol names will always appear in the
  package (sane-package). Since gensyms have null packages, this means that it
  is, for now, impossible to use them as names for keyword arguments. Of course,
  gensyms are generally useless as keyword arguments anyway, so this shouldn't
  matter.


* TODO:

  - implement dictionaries in dict.lisp
  - make PATTERN-VARS smarter
  - implement DEFN
  - implement protocols
  - set up syntax highlighting and indentation
  - schema index sets
  - add slices and iterators
  - add lazy lists and teach fold, map, and filter about them
  - add 


* Misc functions/macros

  - defschema
  - with-fields, with-fields*
  - match
  - dict
  - new
  - @
  - fold, map, filter, zip


* design ideas

  - parentheses denote code objects. quote and backquote return code objects
    that can be used by the program. Unquoted code is evaluated. Code objects
    are made out of primitive types, symbols, and conses.
  - square brackets are for lists (and consequently trees). Lists are singley
    linked in classic lisp fashion. We use the ampersand (&) instead of the dot
    for inline conses.
  - rejected idea (don't repeat this mistake): & is a function so (& a b c) :=
    [a b & c].
  - make objects with the keyword NEW. Schemas decide their own constructor
    parameters
  - Every schema has a corresponding pattern matcher
  - When looking up an object's schema, we will use the class name of the object
    as the key for a hash table. This is to make the lookup as fast as possible.


* Experimental Zone

  This is where I'm gonna put some wild ideas that I'm not sure about.

** schemas with custom internal data structures

   eee

   
** protocols (polymorphism)

   I really like how protocols work in SML/how type classes work in Haskell.
   However, these implementations are indelibly tied to the static type system.
   Here's an example: suppose we wanted to define a sequence type class in
   Haskell. We want our sequence types to satisfy two requirements: we can
   create an iterator from any sequence, and we can get an empty version of that
   sequence. We can define our iterator and sequence typeclasses like so

   #+BEGIN_SRC haskell
   class Iterator a where
       hasNext :: a -> Bool
       iterNext :: a -> a
       iterGet :: a -> b

   class Sequence a where
       empty :: a
       iterator :: Iterator b => a -> b
       conc :: a -> a -> a

   -- example instance
   data ListIt = ListIt lst
   instance Iterator ListIt where
     hasNext (ListIt lst) = lst == []
     iterNext (ListIt lst) = ListIt (tail lst)
     iterGet (ListIt lst) = head lst

   instance Sequence [a] where
     empty = []
     iterator x = ListIt x
     conc x y = x ++ y

   #+END_SRC

   Don't try running this code. I haven't written Haskell in a while. Even so,
   this example is instructive, as it reveals some of the key features of an
   effective ADT protocol system.

   It is immediately clear that we want two new special forms to implement
   protocols. We will define protocols with defproto, and create implementations
   with defimpl. In addition, we will need to define some sort of symbol which
   corresponds to the designated type (in the Haskell example, it's the variable
   a).

   Also, we can see that the empty method is not a function. Rather, it works
   like a variable, with the type system doing the heavy lifting-- in Haskell's
   case, the compiler decides which version of empty to use based on the type
   expected in the code. Haskell is pretty cool.

   To emulate this behavior in FN, we would like a way to define a function
   (empty TYPE) which takes the type name as a symbol. E.g. (empty 'list) =>
   NIL. In addition, we will need a way to specify methods that accept arguments
   of the given type.

   I have a solution which I believe kills two birds with one stone.

 
** matching in lambda lists (actually this feature sucks)

   In Common Lisp, we have these &-symbols for special arguments:

   #+BEGIN_SRC common-lisp
   (defun f (&optional fuck-me-sideways) ...)
   #+END_SRC

   But, we could also have these things:

   #+BEGIN_SRC common-lisp
   (defun f (&match [x y z]) ...)
   #+END_SRC

   which would do pattern-based destructuring on the argument.

   One problem is that we've nixed &-symbols in our version of defun, so we have
   parenthesized forms for variable names and keywords. Even then, it would be
   cumbersome to type &match before every pattern argument.


** unified definition

   First off, let's not kid ourselves: DEFPARAMETER is too long of a name.
   DEFVAR is not so bad, but usually we want DEFPARAMETER behavior, rather than
   DEFVAR behavior.
   
   Currently, I've decided to use DEF for declarations, SET for updates, CONST
   for constants, and DEFN for functions.

   #+BEGIN_SRC common-lisp
   (defparameter x 6)
   ;; => (in FN)
   (def x 6)

   (defconstant pi 3.14)
   ;; =>
   (const pi 3.14)

   (defun log (x &optional (base 10))
     ...)
   ;; =>
   (defn log (x (base 10))
     ...)
   ;; or, equivalently, (but not until the future)
   (def log
     (fn (x (base 10))
       ...))
   #+END_SRC


** function options

   Functions look like this:

   (fn (args) body)

   We would like to customize function behavior. If the first argument of the
   function body is a dict form (denoted below with braces), and the body has
   length > 1, then we will use that dictionary as the function options:

   (fn (args)
     {:option-name option-value ...}
     body)

   Some ideas for options are:

   - :type, :optimize, :ignore, ignoreable :: replace DECLARE forms
   - :inline BOOL :: whether to inline this function
   - :curry N :: automatically curry up the first N arguments. Or, if N is true,
                 then curry all positional arguments (default: false, eqv. 0)
   - :memo BOOL :: memoize the function if true (default: false)
   - :doc STR :: docstring (only in definitions)
   - :arg-doc LIST :: argument documentation (only in definitions)


** RADICAL: Immediate type syntax (Forget about QUOTE)

   *BIG note:* quote is useful within quasiquote, as we can write e.g.
   `(symbol-name ',x) to get a quoted version of a symbol within the quasiquote
   body. Otherwise we must write `(symbol-name (quote ,x)), which could get
   cumbersome quickly. Thus it's probably better not to touch this.

   Here we will explore syntax for immediate types. First, we will enumerate the
   essential types and their syntax in plain ol' CL

   - symbol :: 'sym or `sym
   - keyword :: :key
   - integer (base 10) :: 101
   - integer (base 16) :: #xb00b5
   - integer (octal) :: #o777
   - character :: #\c
   - float :: -1.237, 1.2938e9, etc
   - string :: "str"
   - bool :: T or NIL

   I would like it if we could do 0x2a for hexadecimal and 0o755 for octal.

   In addition, it would be possible, I think, to get rid of single quote for
   variables and simply use the backtick everywhere instead. Then, single quotes
   could be used for strings or characters, but this would really fuck with
   paredit so maybe it's a distant future sort of change. However, doing so
   would also let us reclaim the # character.


** Is this be a LISP-2?

   No. Well, it's not supposed to be. At the moment, there are still,
   unfortunately, relics of Common Lisp's silly old variable system. There's no
   easy way to declare global lexical variables, so we do our best.


*** Rationale


*** Implementation of Lexical Scope

    It's a lot of work to fake global lexical scope in Common Lisp, and the lack
    thereof is the single biggest problem I have with language. So, we do
    something a little whacky. We will override the left paren reader as
    described in the other Implementation section. This gives us the ability to
    have any expression in the operator position of a compound expresion. That's
    a good start.

    Whenever we define a global (non-dynamic) variable, we do a few things. We
    will also create a symbol macro with the same name that expands to
    (LEXICAL-VALUE 'SYMBOL). LEXICAL-VALUE itself is a magic macro that determines
    whether the variable is bound locally, and, if it is, expands to that
    symbol. Otherwise, it expands to get the LEXICAL-BINDING field from a
    symbol, which is where we put lexically bound variables.

    In addition to the LEXICAL-BINDING field of the symbol, we also set the
    function field for the symbol when the field is a function. This requires us
    to be very careful with how we mutate variables. That is, we must carefully
    set and unset the function field of a symbol when we change its value.
    Moreover, we have to be careful


*** Implementation 1

    A partial implementation is actually quite straightforward to implement in
    Common Lisp, but it involves changing the behavior of the reader macro for
    the left paren, which feels very dirty. I like it.

    Dumb jokes aside, the implementation would be easy and involve two steps.
    First of all, we would make DEF and DEFN assign both the variable and the
    function slots of a symbol. Then we redefine the left paren. The new reader
    would simply invoke the old one, check if the first item in the list is a
    symbol, and if it isn't, then expand it to a FN-FUNCALL form. FN-FUNCALL
    behaves like FUNCALL, except that it is also a compiler macro which will
    strip out CELL-VALUE calls (see the other implementation section), thereby
    eliminating the middle-man in 

    One problem we would run into is that code pulled in from other common lisp
    packages would not have its functions in the variable space, so we would
    still need to use the pointy #'FUN syntax for those guys. Provided there are
    no collisions in the exported symbols in function/variable space, it would
    be possible to automatically convert LISP-2 code to FN, but it probably
    isn't worth the trouble.


** Local definitions


* Immediate future

