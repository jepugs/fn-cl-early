#+TITLE: fn Language Reference (WIP)

* This document is undergoing a major revision

There are some things that are quite outdated. With luck the whole thing will be updated soon. At
the time of writing, the [[syntax][Syntax]] section is the only one which may be considered complete. The other
stuff is mostly accurate too. 

To further complicate things, the programming language is not fully implemented in the interpreter
yet. Please stand by.

* Introduction

fn is a programming language in the Lisp family. It will feature a robust and streamlined object
system, an intuitive module-based approach to code organization, powerful metaprogramming
facilities, and a variety of quality of life features that aid in writing especially concise code
without sacrificing clarity.

** fn compared to other dialects of Lisp

Compared to most dialects of Lisp, fn has a small number of special forms, several new syntactic
conveniences, and a strong focus on its native object system. The object system strives to avoid
several problems with CLOS, namely its feeling tacked-on to the rest of the language (because it
was) and being rather verbose.

In addition, fn code is homoiconic like Common Lisp, allowing writing of macros in the traditional
Lisp way, which I greatly prefer to the hygienic macros and templates of e.g. Racket or Scheme.
However, unlike Common Lisp, where even "properly-written" macros can break in the case of an
esoteric name collision, fn allows functions and variables to be looked up during macroexpansion in
order to avoid such issues. Thus the goals of hygiene may be achieved without resorting to using
special syntax objects or creating a pattern-based DSL.


** Implementation notes

- Everything is implemented in Common Lisp. The only supported implementation is SBCL. No particular
  effort is made to maintain ANSI compliance, although most of the code is ANSI anyway.
- This code is only tested on a handful of my personal computers, all of which run Arch Linux.
- I am currently in the process of rewriting fn. The previous version, which was nearly a feature
  complete version 0, was built as a layer on top of Common Lisp, using the Common Lisp reader and
  macros to implement almost all of its features. This new version will be a proper interpreter.


* <<syntax>>Syntax

Expressions[fn:1] in fn are built from what are termed *forms*. The *forms* are a superset of all valid
expressions in fn (i.e. all expressions are forms, but the converse is not true)[fn:2]. There are
two varieties of forms: *lists*[fn:list-forms] and *atoms*. <<def:list-form>> *Lists* are compound forms
which may contain other forms. We often refer to lists by their first subform, termed the *operator*.
For example, ~(get a b)~ could be called a ~get~ form. <<def:atom>> *Atoms* are defined by the fact that
they contain no subforms, and are divided into three kinds: symbols, numeric constants, and string
constants.

#+BEGIN_SRC fn
;;; examples of atoms and lists
;;; lines beginning with ; are comments

;;; strings
"string"
"hello, world!"
;; all C++-style string escape codes may be used
"\"quotes\""
"multi-\nline"

;;; numbers
1
1.2
-34
2.3e-4

;;; symbols
x
var
Table
;; symbols in fn can contain a variety of non-alphanumeric characters
multiple-word-function-name
$it
+
*
;; symbols may include numbers, even at the beginning
1st
2nd
times-2
;; \ is a universal escape character which allows any character to be included in a symbol name, 
;; including whitespace, so the following is actually a valid symbol.
C:\\Program\ Files\\

;;; lists are usually denoted by parentheses
(+ 2 5)
(+ (- 5 3) 6)
;; fn is an example of a special operator; specifically, it is used to create functions
(fn (x) (* x 2))
;; the empty list, an example of a form that is not a valid expression on its own
()
#+END_SRC

[fn:1] Many programming languages also have /statements/, which are constructs that perform an action
without returning any value. fn does not, although many types of expressions, such as definitions,
may have their return value safely ignored.

# TODO: link to macros section
[fn:list-forms] The word "list" can also refer to fn's built-in linked list data structure. When
saying "list" would be ambiguous, we will use the phrases *list form* and *list object*. As a sidenote,
list forms have the same internal representation as list objects, making it easy to manipulate fn
source code from within an fn program. This property is central to fn's metaprogramming facilities,
which allow new syntax to be defined with relatively little effort.

# TODO: link to macros section
[fn:2] The line between forms and expressions can be blurry. For instance, the empty list ~()~ is not
a legal expression on its own, but it is perfectly fine when it appears as a parameter list for a
function, e.g. in the expression ~(fn () 17)~ which creates a constant-valued function of no
arguments. This distinction is further exacerbated by the fact that fn's macro system allows
definition of new syntax by manipulating forms prior to execution. A useful way to think about it is
this: invalid /forms/ cause errors during /parsing/, while invalid /expressions/ cause errors during
/evaluation/ (aka execution).

** <<syntax.atoms>>Atom Syntax In Depth

*IMPLNOTE:* The current version of the interpreter does not respect octal or hexadecimal string escape
characters or exponential notation for numbers.

*** <<syntax.strings>>Strings

Strings begin and end with double quotes, ~"~. Everything between the quotes is part of the string.
Strings containing the character ~"~ may be created by using the escape sequence ~\"~ e.g. ~"\""~ is a
length-1 string containing a double quote character. In addition, the following escape sequences are
provided:

| Escape sequence                           |                                             |
|-------------------------------------------+---------------------------------------------|
| \a                                        | ASCII bell                                  |
| \b                                        | ASCII backspace                             |
| \f                                        | form feed                                   |
| \n                                        | newline (line feed)                         |
| \r                                        | carriage return                             |
| \t                                        | tab                                         |
| \v                                        | vertical tab                                |
| \'                                        | single quote[fn:useless-esc]                |
| \"                                        | double quote                                |
| \?                                        | question mark[fn:useless-esc]               |
| \\                                        | backslash                                   |
| \xHH (HH is a 2-digit hexadecimal number) | insert character by its hexadecimal code HH |
| \OOO (OOO is a 3-digit octal number)      | insert character by its octal code 000      |

Unlike in some languages, newline and tab characters are preserved when strings are parsed.


[fn:useless-esc] These escape codes are retained for compatibility with C string syntax and are not
particularly useful

*** <<syntax.numbers>>Numbers

Numbers are atoms consisting of numeric characters. In addition,

- The first character may be + or -. (Note: these characters by themselves are symbols, not
  numbers)
- There may be exactly one occurrence of ~.~ anywhere in the atom
- There may be exactly one occurrence of ~e~. The ~e~ may not occur at the beginning or end of the
  number and must come after any occurrence of ~.~ (dot).

Numbers may not contain escaped characters, e.g. ~1\0~ is a symbol rather than a number.

*** <<syntax.symbols>>Symbols

A symbol is denoted by a series of permissible characters that does not form a valid number, (see
[[syntax.numbers]]). Before accounting for escaping, symbols may contain any ASCII characters other than
whitespace or these glyphs[fn:glyph]:

#+BEGIN_SRC
`()[]{};'",.
#+END_SRC

In addition, any ASCII character can be used as part of a symbol by prefixing it with the escape
character ~\~.

Symbols are terminated by the first unescaped non-symbol character after the start of the symbol.
Care should be taken when using the character ~$~ as a symbol constituent, as the two-character
sequences $(, $[, ${, and $` are used for special anonymous function syntax, see [[syntax.dollar]]

[fn:glyph] The word "glyphs" is used here to distinguish symbol characters from the fn concept of a
symbol.


** <<syntax.parens>>Parenthesized Lists

Parenthesized lists consist of a series of forms contained within a matching pair of parentheses.
They can be nested to an arbitrary depth.

All other list syntax can be rewritten using parenthesized lists alone. In fact, the interpreter
converts other types of list syntax to have the same internal representation as parenthesized lists
before evaluating them, see [[syntax.lists]].


** <<syntax.lists>>Other List Syntax

All fn code can be represented using parenthesized lists alone, however several other ways to create
list forms are provided for convenience. The interpreter expands these forms into parenthesized
lists before evaluating them. The expansion happens regardless of the context in which these forms
appear (but not in string literals, as those are an entirely different type of form).

# TODO: add links to relevant special forms

*** <<syntax.brackets>>Square Brackets

Bracket forms consist of a matched pair of square brackets containing a (possibly-empty) sequence of
forms. Square brackets are used to create list objects in fn programs. Accordingly, they expand to
~List~ forms, ~List~ being the class of fn's built-in list objects.

#+BEGIN_SRC fn
[x y z]
;; expands to
(List x y z)

[]
;; expands to
(List)
#+END_SRC

*** <<syntax.braces>>Braces

Brace forms consist of a matched pair of braces containing a (possibly-empty) sequence of forms.
Braces are used to create table objects in fn programs. Accordingly, they expand to ~Table~ forms,
~Table~ being the class of fn's built-in list objects.

#+BEGIN_SRC fn
{key1 value1 key2 value2}
;; expands to
(Table key1 value1 key2 value2)

{}
;; expands to
(Table)
#+END_SRC

*** <<syntax.quote>>Quotation

The characters ~'~, ~`~, and ~,~, and the two-character sequence ~,@~ are used for various quotation
facilities. Each one must be followed immediately by zero or more whitespace characters and then a
form. They all create lists of two elements where the first element is a special quotation operator
and the second element is the succeeding form. The operators, respectively, are ~quote~, ~quasiquote~,
~unquote~, and ~unquote-splice~.

#+BEGIN_SRC fn
'a
;; expands to
(quote a)

'(a b)
;; expands to
(quote (a b))

`x
;; expands to
(quasiquote x)

,y
;; expands to
(unquote y)

,@y
;; expands to
(unquote-splice y)
#+END_SRC

*** <<syntax.dollar>>Dollar Sign

Dollar sign syntax is used to create ~dollar-fn~ forms, which are a convenient way to create
functions. It consists of the dollar sign character ~$~ followed immediately (i.e. without any
interposed whitespace) by a [[syntax.parens][parenthesized list]], a [[syntax.brackets][bracket]] form, a [[syntax.braces][brace]] form, or a [[syntax.quote][quasiquote]] form.
In each case, the following form is wrapped in a ~dollar-fn~ form of a single argument.

#+BEGIN_SRC fn
$(+ x $)
;; expands to
(dollar-fn (+ x $))
;; note that the second dollar sign is treated as a normal symbol

$[]
;; expands to
(dollar-fn (List))

$`(+ ,$ 5)
;; expands to
(dollar-fn (quasiquote (+ (unquote $) 5)))
#+END_SRC

*** <<syntax.dot>>Dot

Dot syntax is used to access the fields of an object. It consists of two or more symbols separated
by ~.~ (dot) and expands to a ~get~ expression. In the case where there is only one dot, the first
argument to the ~get~ expression is the left side of the dot, and the second argument is the right
side, but wrapped in a ~quote~ form. When there are multiple dots, a nested ~get~ form is created by
applying this rule in a left-associative manner.

#+BEGIN_SRC fn
a.b
;; expands to
(get a (quote b))

a.b.c
;; expands to
(get (get a 'b) 'c)
#+END_SRC

A <<def:dotted-get>> *dotted get form* is any ~get~ form which could be written using dot syntax alone.
Dotted get forms are used to look up macros, methods, and variables


* Modules and Name Resolution

** Definition order

In fn, loading source files behaves as is they are evaluated one expression at a time from beginning
to end. Function and variable lookups may be performed at runtime, so a function may use a variable
or another function whose definition appears later in the file.

The same rules generally apply to macros, but with some gotchas. Macros may be defined in the same
file they are used in, but must be appear (lexically) before any uses. If a macro uses a function to
create its expansion, then that function must be defined before the macro is first expanded (duh)


** Modules

Right now, modules have a 1-to-1 correlation with fn source files. To import a file, you use import
with a symbol corresponding to the file name, without any extension.

#+BEGIN_SRC fn
;; imports from file "x.fn" and binds the module as x
(import x)
;; imports from file "x.fn" and binds the module as y
(import x 'as y)
;; imports from file "x.fn" and binds all variables locally
(import x 'as _)
#+END_SRC

Modules are first class objects and their variables may be accessed using ~get~ or dot syntax.

#+BEGIN_SRC fn
;; file my-module.fn
(def my-var 26)

;; file example-a.fn
(import my-module)
my-module.my-var ;=> 26

;; file example-b.fn
(import my-module 'as mod)
mod.my-var ;=> 26

;; file example-c.fn
(import my-module 'as _)
my-var ;=> 26
#+END_SRC


*** Implementation note: modules, macros, and dynamic vars

In Common Lisp, importing a macro means importing a symbol from another package. E.g. I import ~LOOP~
from ~CL~ and now every time I type ~loop~ it gets silently converted to ~CL:LOOP~. This allows a
one-to-one correspondence between macros and the symbols that represent them. At evaluation time, we
are guaranteed that the operator for a macro expression will always be a symbol, and its just a
matter of looking in that symbol's macro binding slot. In ~fn~, we no longer have the guarantee that
the operator is a symbol, and we have first-class module objects instead of packages, so we need to
take a more sophisticated approach.

The interpreter will internally maintain a list of which symbols (if any) are bound to modules.
Then, to do macro expansion on a list, we perform two checks: first, whether it's a symbol bound to
a macro in the current module (duh). If not, we check next whether the operator is a ~get~ expression.
If it is, and its first argument is a symbol referencing an imported module, then we can check that
module for macro bindings as well. This allows painless use of macros from other modules.


*** Future extension: ~__modules.fn~

In the future, a file named ~__modules.fn~ may be added to a source directory in order to define
modules that don't correspond directly to files and to modify the search path on a per-project
basis. In addition, it will be possible to automatically define wrapper modules that import all
their variables from submodules in order to create cleaner interfaces.


** Import semantics

Modules may be imported using strings, symbols, or dotted get expressions. Strings are plain UNIX
path names, while symbols and dots use the module search path, which is
".:~/.local/lib/fn/modules:/usr/local/lib/fn/modules:/usr/lib/fn/modules". Each of these
directories is checked in order for the given module.

#+BEGIN_SRC fn
;;; all these import forms bind the module to a variable named symbol

;; look for "symbol.fn" in the module search path
(import symbol)

;; look for "symbol.fn" in the current directory
(import "symbol.fn")

;; look for "pkg/symbol.fn" in the module search path
(import pkg.symbol)

;; look for "pkg/symbol.fn" in the current directory
(import "pkg/symbol.fn")

;; look for the absolute path "/usr/lib/symbol.fn"
(import "/usr/lib/symbol.fn")
#+END_SRC


** Dynamic variables

In fn, dynamic variables may be created using ~defvar*~. In keeping with lisp tradition, we
recommend naming dynamic variables with earmuffs. (No ~def*~ form is included, because all dynamic
variables need to be resolved, well, dynamically, so they might as well be mutable).

#+BEGIN_SRC fn
(defvar* *name* initial-value)
#+END_SRC

This declares ~*name*~ to be a dynamic variable. Dynamic variables may be rebound with ~let~.

#+BEGIN_SRC fn
(defvar *special-x* 27)

(def (get-value) *special-x*)

(get-value) ;=> 27
(let (*special-x* 420)
  (get-value)) ;=> 420
(get-value) ;=>27
#+END_SRC

IMPORTANT NOTE:* Unlike in other dialects of lisp, special variables must be declared before they
are treated as special. Uses prior to that point will be treated as normal lexical variables.
Example:

#+BEGIN_SRC fn
(def (call-with-square-0 fun x)
  (let (sq (* x x))
    (fun sq)))

;; Note: In real code, global variable should never have such terse names
(defvar* sq 16)

(def (call-with-square-1 fun x)
  (let (sq (* x x))
    (fun sq)))

(def (get-sq _) sq)

;; call-with-square-0 treats sq as a normal lexical variable because it was defined before sq was 
;; declared dynamic.
(call-with-square-0 get-sq 6) ;=>16

;; call-with-square-1 treats sq as a dynamic variable
(call-with-square-1 get-sq 6) ;=>36

#+END_SRC


* Functions

There are two special operators that create functions: ~fn~ and ~dollar-fn~. The latter is usually
written using dollar-sign syntax. The expression ~$(function-body)~ expands to ~(dollar-fn
(function-body))~.

#+BEGIN_SRC fn
  ;; syntax for fn is
  (fn (<parameters>) <body>)

  ;; there are three kinds of parameters recognized by fn: positional, keyword, and variadic.
  ;; Positional params are denoted by plain symbols and keyword params by quoted symbols. Variadic
  ;; parameters are defined by using the special symbol & followed by a symbol indicating the name of
  ;; the variable.

  ;; function that takes two positional arguments and sums their reciprocals
  (def sum-inv 
    (fn (x y)
      (+ (/ 1 x) (/ 1 y))))
  (sum-inv 0.5 0.2) ;; => 7

  ;; function that takes one positional argument and two keyword arguments. This function will 
  ;; apply the function if-num if v is a number, otherwise it will apply 'otherwise.
  (def apply-if-num
    (fn (v 'if-num 'if-not)
      (if (num? v)
          (if-num v)
          (if-not v))))
  ;; to call functions with keyword arguments, simply put the quoted symbols in the argument list
  (apply-if-num "hello" 'if-num String 'if-not println) ;; prints "hello"
  ;; keyword arguments may be provided in any order
  (apply-if-num 2 'if-not println 'if-num String) ;; => "2"

  ;; keyword and positional parameters can be made optional by putting them in parentheses followed 
  ;; by a default expression. Required parameters may not succeed optional ones.
  (def increment (num (by 1))
    (+ num by))
  (increment 17) ; => 18 (uses default value for by)
  (increment 17 2); => 18

  ;; variadic arguments must come last in an argument list.
  (def string-sum (& numbers)
    (String (apply + numbers)))

#+END_SRC

*** Wildcard parameters

Positional parameters using the wildcard symbol "_" are treated specially. Such parameters do not
cause any variables to be bound in the function body, i.e. the argument in the corresponding
position is ignored. These may also be used as optional arguments, although a dummy default value
must still be provided, e.g. ~(_ null)~


*** Variadic arguments and keywords

When a function accepts both keywords and variadic arguments, all the variadic arguments must be
alternating symbol and value pairs, just like normal keyword arguments. This behavior is very
similar to the behavior of combining ~&REST~ and ~&ALLOW-OTHER-KEYS~ in Common Lisp. The one difference
is that the property list bound to the variadic argument will not contain any of the explicitly
specified keyword parameters. That is:

#+BEGIN_SRC fn
(def (fun 'key1 & other-keys)
  other-keys)

;; other-keys will not contain the value for 'key1
(fun 'key1 4 'key2 6 'key3 8)
;; => ('key2 6 'key3 8)

#+END_SRC

Functions which accept both variadic arguments and keywords have argument checking done to make that
the keyword arguments form a plist. To get argument checking without having any explicit keyword
arguments, include "'_" (quote underscore) in the parameter list.

#+BEGIN_SRC fn
;; this function accepts any arguments
(def (fun1 & args)
  args)
;; so this is fine
(fun1 'key 2 3.14159 "hello" 'key2)

;; this function only accepts arguments that form a proper plist
(def (fun2 '_ & args)
  args)
;; this is an error
(fun2 'key 2 3.14159 "hello" 'key2)
;; but this is fine
(fun2 'key 2 'key2 "hello")

#+END_SRC


* Parameter lists

Parameter lists play an important role in fn. They control the arguments accepted by functions,
methods, and macros, but they are also used to define classes and to do pattern matching.

** Parameter List Syntax and Function Calls

A parameter list is a code list consisting of parameters. There are four kinds of parameters in fn,
which are described below, followed by sample code. Every parameter, regardless of its type, has a
symbol associated with it, called its *name*. With the exception of the wildcard symbol ~_~ (see
[[params.wild]]), every name must be unique w/r/t the rest of the parameter list.

- required positional parameters (RPP) :: denoted by plain names, these arguments must come first
     in the parameter list. If an RPP is found after any other type of parameter in the list, an
     error is generated.
- optional positional parameters (OPP) :: denoted by length-2 lists where the head is the name and
     the second element is a default expression. OPPs come after RPPs but before other types of
     parameters. If OPPs are not provided, their default expressions are evaluated to determine a
     value. This is done every time the function is called. The expression is evaluated in the
     lexical environment in which the function was created, so a surrounding ~(let...)~ block can be
     used to avoid recomputing default values.
- keyword parameters (KP) :: denoted by quoted symbols or length-2 lists where the head is a quoted
     name and the second element is a default expression.
- variadic parameters (VP) :: must come last in a parameter list. VPs are denoted by the symbol ~&~
     followed by a plain symbol. The value of a VP depends on whether the parameter list contains
     any keyword parameters. If it doesn't, then the VP is bound to a list of all arguments after
     the last positional argument. Otherwise, it is bound to a list of all values after the last
     positional argument EXCEPT the symbol-value pairs corresponding to explicit keyword arguments.
     In the latter case, all the non-positional arguments must have an alternating symbol-value
     form, as if they were all keyword arguments. If this behavior is desired but there are no
     explicit keyword arguments, then a wildcard keyword parameter may be supplied (see
     [[params.wild]]).

#+BEGIN_SRC fn
;;; example: this function has every type of parameter. Two RPPs, one OPP, two KPs, and a VP.
(def (params-demo rpp0 rpp1 (opp2 null) 'kp3 ('kp4 true) & vp5)
  (String "rpp0 = " rpp0 "\nrpp1 = " rpp1
          "\nopp2 = " opp2 "\nkp3 = " kp3
          "\nkp4 = " kp4 "\nvp5 = " vp5))

;; As few arguments are supplied as possible. opp2 and kp3 default to null, kp4 defaults to true,
;; and vp5 is bound to empty list.
(params-demo 0 1)
;; =>
"rpp0 = 0.0
rpp1 = 1.0
opp2 = null
kp3 = null
kp4 = true
vp5 = []"

;; manually specifying every argument in order
(params-demo 0 1 2 'kp3 3 'kp4 4 'kp5 5 'kp6 6)
;; =>
"rpp0 = 0.0
rpp1 = 1.0
opp2 = 2.0
kp3 = 3.0
kp4 = 4.0
vp5 = [kp5 5.0 kp6 6.0]"

;; manually specifying every argument, with keywords out of order
(params-demo 0 1 2 'kp4 4 'kp6 6 'kp3 3 'kp5 5)
;; =>
"rpp0 = 0.0
rpp1 = 1.0
opp2 = 2.0
kp3 = 3.0
kp4 = 4.0
vp5 = [kp6 6.0 kp5 5.0]"
;;; Note that the value of vp5 has keyword arguments in the order they were passed, but omits the
;;; explicit keyword arguments 

;; this causes an error, because even though there is a variadic parameter, the variadic arguments 
;; are not symbol/value pairs.
(params-demo 0 1 2 'kp3 3 'kp4 4 5 6)

;; keyword parameters are not magic. While they are usually passed using quoted symbols in the 
;; function call, they may also be specified using variables, apply, etc
(let (first-keyword-sym 'kp3)
  (apply params-demo 0 1 2 first-keyword-sym [3 'kp4 4]))
;; =>
"rpp0 = 0.0
rpp1 = 1.0
opp2 = 2.0
kp3 = 3.0
kp4 = 4.0
vp5 = []"

;;; this function demonstrates non-keyword variadic arguments
(def (params-demo1 rpp0 & vp1)
  (String "rpp0 = " rpp0 "\nvp1 = " vp1))
(params-demo1 0 1 2 3)
;; =>
"rpp0 = 0.0
vp1 = [1.0 2.0 3.0]"
#+END_SRC

** <<params.wild>> Wildcard Parameters

The symbol ~_~ is called a *wildcard parameter*. It may appear anywhere 

** Class Pattern Matching

In order to do 


* Classes and Methods

fn is an object-oriented programming language. Every value in fn is an object, and every object is
an instance of some class, which describes the object's structure. Polymorphism is provided via
methods, which are callable objects that perform different actions based upon the classes of their
arguments.

** Anatomy of an Object

Objects are key-value stores where the keys are symbols called the *fields* of the object and the
values are arbitrary. In addition, every object has a *class* which may be accessed using the built-in
~class-of~ operator. The class contains a list the object's fields as well as a symbol representing
the class's name.


** Classes

Classes are defined using the ~defclass~ operator, which creates a global variable holding a ~Class~
object. Class objects are created based upon a parameter list. This parameter list serves two
functions. First, the variables in the parameter list denote the fields of the class. Second, the
constructor for the class(, invoked by calling the class as an object,) uses the parameter list to
process its arguments.

By convention, type names begin with capital letters.

#+BEGIN_SRC fn
;; class definition
(defclass (Class-Name & params))

;; to invoke the constructor, use call the class like a function
(Class-Name & args)

;; Access fields directly
(get-field obj 'field)
(set (get-field obj 'field) new-value)

;; Access fields via the generic accessors
(get obj 'field)
(set (get obj 'field) new-value)
;; or, equivalently,
obj.field
(set obj.field new-value)
;; this dot notation is preferred wherever possible

;; we can even get fields from the Class itself
(get Class-Name 'fields) ;=> params
(get Class-Name 'name) ;=> 'Class-Name


;; if Class were defined with defclass: (note: it wasn't and there's no constructor)
(defclass (Class name fields constructor))
(class-of class)
#+END_SRC

*** Future features

Options should allow customization of the object's internal representation, constructor, and fields.
E.g. fields may be marked mutable or have type restrictions applied.


** Polymorphism via Methods

fn provides polymorphism in the form of methods. fn's methods support multiple dispatch (i.e. they
are multimethods). The syntax is demonstrated below.

#+BEGIN_SRC fn
;; To define a multimethod, you must specify its name, a list of one or more dispatch parameters,
;; and a parameter list containing all the dispatch parameters.

(defmethod ((<name> <dispatch-params>) <params>))

;; Methods are implemented using def. Syntax is very similar to function definition except that
;; the name of the method and the dispatch types must also be specified.
(def ((<name> <dispatch-classes>) <params>)
  <implementation-body>)

;;; EXAMPLE: the call method (used to treat arbitrary objects as functions)
;; call does dispatch on the argument obj
(defmethod ((call obj) obj & args))

;; implementation of call on classes
(def ((call Class) class & args)
  (apply class.constructor args))

;;; EXAMPLE: the mul method used to extend multiplication.
;; mul does multiple dispatch on the arguments l and r
(defmethod ((mul l r) l r))

;; implement methods using def. Parameter names may be changed.
(def ((mul Num String) ct str)
  (loop (i res) (ct "")
    (if (= i 0)
        res
        (recur (- i 1)
               (append res str)))))

(def ((mul String Num) str ct)
  ;; simply flip the arguments 
  (mul ct str))

#+END_SRC

*** Implementation

Dispatch is done using hash tables. The keys are lists of Class objects.


** Built-in classes

The following classes are built into fn.

*Atomic types*
- Symbol :: symbol
- Bool :: boolean denoted ~true~ or ~false~
- Null :: unassigned value denoted ~null~
- Num :: 64-bit floating-point number

*Structure types*
- Class :: the type of types
- List :: singley-linked list
- String :: character string

(Hash-)tables, arrays, foreign data structures and byte arrays are planned for the future.


* Error reporting

One of the priorities in implementing fn is high quality error reporting. Every error should include
a location in the fn source code, the name of the offending operator, and a short description of
what went wrong.

The phases in which errors can be generated are
- scanning
- parsing
- code validation
- runtime

All errors begin with a line providing the name of the Common Lisp package where the error was
detected and the fn source code location. The next line contains a message describing the error
indented four spaces. Example:

#+BEGIN_SRC
> (]
FN.PARSER error at line 1, col 2:
    Mismatched delimiter "]" (opening delimiter "(" at line 1, col 1)
#+END_SRC

Runtime error messages begin with the string "Runtime error: ". When the name of an operator is
available, that comes next, followed by another colon. Then the error is described. Messages may be
multiple lines long. Generally, messages should start with capital letters, but names of symbols
should never be capitalized differently from how they appear in the code. Example:

#+BEGIN_SRC
> (+)
FN.EVAL error at line 1, col 3:
    Runtime error: +: Too few arguments
#+END_SRC

Naturally, the next step will be printing a stack trace.


* Comprehensive language description

This section completely (and formal-ish-ly) describes the current language design. The interpreter
does not include

** Notation

Operators are documented using syntax that looks like this: ~(op <var1> <vars*>)~. In this example, op
is a literal code symbol, <var1> is a single user-specified expression, and <vars*> is an inline
sequence of other expressions. In general, the symbols in angle brackets are parameters for the
operator while unbracketed. A Kleene star (*) in angle brackets always indicates a sequence.

In addition, some names have more specific meanings:

- <body*> :: a series of one or more expressions constituting a valid function body
- <obj> :: is an expression yielding an arbitrary object
- <params*> :: an fn parameter list like those used in function creation

** Syntax
*** BNF

Below is the BNF used to parse the language. It is presented as the same LR(1) grammar used by the
interpreter.

#+BEGIN_SRC
<program> ::= <expr>*
<expr>    ::= <atom>
            | <group>
            | <dot>
            | <dollar>
            | <quoted>
            | <unquoted>
            | <unquote-spliced>
            | <quasiquoted>

<atom> ::= <symbol> | <number> | <string>

<group>     ::= <list> | <brackets> | <braces>
<list>      ::= "(" <expr>* ")"
<brackets>  ::= "[" <expr>* "]"
<braces>    ::= "{" <expr>* "}"

<dot> ::= <dot-part> <symbol>
<dot-part> ::= <symbol> "." | <dot> "."

<dollar> ::= "$(" <expr*> ")"
           | "$[" <expr*> "]"
           | "${" <expr*> "}"
           | "$`" <expr>

<quoted>           ::= "'" <expr>
<unquoted>         ::= "," <expr>
<unquote-spliced>  ::= "," <expr>
<quasiquoted>      ::= "`" <expr>
#+END_SRC

Where <symbol> is a symbol, <number> is a number, and <string> is a string literal.

** Special operators

Below is a complete list of fn's special operators. Operators marked done are fully documented below
and implemented in the interpreter

*** DONE ~apply~

#+BEGIN_SRC fn
;;; syntax - apply
(apply <obj> <args*> <arg-list>)
;;; where
;; <obj> is a callable object
;; <args> 0 or more arguments to be passed to <fun>
;; <arg-list> a list of arguments to be passed to <fun>
#+END_SRC

~apply~ invokes an object's call method with elements of the provided list as arguments. If <args*>
are specified before <arg-list> then those arguments are prepended to the arg-list before calling.

*** TODO ~case~

*Impl. status:* ~case~ behavior is not yet fully specified.

*** DONE ~class-of~

#+BEGIN_SRC fn
;;; syntax - class-of
(class-of <obj>)
#+END_SRC

~class-of~ gets the class of an object.

*** DONE ~cond~

#+BEGIN_SRC fn
;;; syntax - cond
(cond <cond-clauses*>)
;;; where
;; <cond-clauses*> is a nonempty even-length sequence of expressions

;;; example:
(def (divisor-search x)
  (cond
    (= (mod x 2) 0) "2 divides x"
    (= (mod x 3) 0) "3 divides x"
    ;; this
    true "neither 2 nor 3 divides x"))
;; only the first truthy condition is used
(divisor-search 6) ;=> "2 divides x"
(divisor-search 12) ;=> "2 divides x"
(divisor-search 9) ;=> "3 divides x"
(divisor-search 5) ;=> "neither 2 nor 3 divides x"

#+END_SRC

~cond~ is a conditional construct. Each cond-clause is two expressions, a condition followed by a
result. Each condition is evaluated in the provided order until one of them evaluates to a truthy
value (i.e. anything other than ~false~ or ~null~). The result of this condition is evaluated and
returned. If no conditions succeed, then ~null~ is returned.

*** DONE ~def~

#+BEGIN_SRC fn
;;; syntax - def
(def <var> <obj>)                              ; var def
(def (<var> <params*>) <body*>)                ; function def
(def ((<method> <types*>) <params*>) <body*>)  ; method def
;;; where
;; <var> is an unbound symbol
;; <types*> is a non-empty sequence of symbols naming classes
;; <method> is a symbol naming a global method
#+END_SRC

~def~ has three forms that each perform a different action. The first form defines an immutable global
variable with the specified value. The second form creates a function named <var> with the provided
params and body. The third form defines a method implementation of <method> on the provided types.

*** DONE ~defclass~

#+BEGIN_SRC fn
;;; syntax - defclass
(defclass (<Name> <params*>) <options*>)
;;; where
;; <Name> is an unbound symbol used to hold the created class object
;; <options*> is a sequence of defclass options
#+END_SRC

~defclass~ creates a new global class object of the given name. The parameter list variables are used
as the class's fields and is also used to define the constructor.

At this time, there are no supported class definition options. Future extensions will allow
declaration of mutable/immutable fields, alternative constructor behavior, and so on.

*** DONE ~defmacro~

#+BEGIN_SRC fn
;;; syntax - defmacro
(defmacro (<var> <params*>) <body*>)
;;; where
;; <var> is a symbol
#+END_SRC

~defmacro~ defines a global macro (local macros do not presently exist in fn). The expansion function
takes the provided params and evaluates <body*>.

Macroexpansion is similar to function calling, except that macros accept and return code objects.
The arguments to a macro are not evaluated, but are quoted and passed directly to the expansion
function. The result of the macro is then evaluated in place of the original list.

Macros are not first class objects, and so they may share names with normal variables. This is
generally not a good idea, but can be useful in some cases (i.e. where a function can be
preprocessed based on its arguments to have a more efficient expansion).

*** DONE ~defmethod~

#+BEGIN_SRC fn
;;; syntax - defmethod
(defmethod ((<var> <dispatch-params*>) <params*>)
  <method-options*>)
;;; where
;; <dispatch-params*> is a sequence of symbols, all of which must appear as names in <params*>
;; <method-options*> is a sequence of method options, none of which are currently defined
#+END_SRC

~defmethod~ defines a new global method object, which is a callable object that has different behavior
depending on the classes of its arguments. The dispatch params determine which parameters are used
to decide the behavior. Method instances (i.e. specific functions for different combinations of
classes) are created using ~def~.

*** DONE ~defvar~

#+BEGIN_SRC fn
;;; syntax - defclass
(defvar <var> <obj>)
;;; where
;; <var> is an unbound symbol
#+END_SRC

~defvar~ defines global mutable variables.

*** TODO ~defvar*~

#+BEGIN_SRC fn
;;; syntax - defclass
(defvar* <var> <obj>)
;;; where
;; <var> is an unbound symbol
#+END_SRC

~defvar*~ defines global dynamic variables.

*Impl. status:* ~defvar*~ is not implemented

*** DONE ~do~

#+BEGIN_SRC fn
;;; syntax - do
(do <body*>)
#+END_SRC

~do~ evaluates the expressions in its body in the order in which they are provided, returning the
result of the last expression.

*** DONE ~dollar-fn~

#+BEGIN_SRC fn
;;; syntax - dollar-fn
(dollar-fn <expr>)
;;; where
;; <expr> is an expression which may contain $-syms

;;; equivalent syntax is
$<expr>
;; however, the dollar sign must not have any whitespace before the expression, and the expression
;; must start with one of these characters: (, [, {, or `.


;;; examples:
;; creates a function of two arguments that adds them
$(+ $0 $1)
;; creates a function of one argument that subtracts six
$(- $ 6)
#+END_SRC

~dollar-fn~ is mainly used via dollar-sign syntax. It provides a convenient notation for short
anonymous functions. To evaluate ~dollar-fn~, the code for <expr> is walked so that $-syms can be
found. $-syms are symbols ~$~, ~$0~, and ~$&~, plus all symbols of the form ~$n~, where ~n~ is a positive
integer with no plus sign or leading 0s, e.g. ~$2~ or ~$11~.

$-syms correspond to positional arguments in the created function. ~$~ and ~$0~ are equivalent, and
denote the first argument, ~$1~ denotes the second, and so on. When ~$&~ appears in the list, it is
bound to a list of all arguments after the last positional argument in the list.

The functions created by ~dollar-fn~ only accept as many arguments as are necessary. If the expression
only contains ~$~, the function will accept exactly one argument, while if its maximum-numbered $-sym
is ~$7~, it will accept at 8 arguments. An expression with ~$&~ will accept any number of arguments, and
a function with no $-syms will accept no arguments.

Nested occurrences of ~dollar-fn~ are not walked for $-syms in the outer ~dollar-fn~. This means that
nesting dollar-fn is legal, but no argument vars from the outer function can be accessed by the
inner function.

*** DONE ~fn~

#+BEGIN_SRC fn
;;; syntax - fn
(fn (<params*>) <body*>)
#+END_SRC

~fn~ creates an anonymous function which accepts the provided parameters and executes the code in
<body*>.

*** DONE ~get~

#+BEGIN_SRC fn
;;; syntax - get
(get <obj> <keys*>)
;;; where
;; <keys*> is a sequence of one or more objects used as keys for obj

;;; dot syntax expands into get expressions
<sym1>.<sym2>
;;; expands to
(get <sym1> '<sym2>)
;;; where <sym1> and <sym2> are both symbols
#+END_SRC

~get~ is used to access the contents of an object using the provided keys. If multiple keys are
provided, then ~get~ is applied recursively using each key in order.

Default behavior for ~get~ depends on the type of the object:

#+BEGIN_SRC fn
;;; strings
;; get a numerical index
(get "test" 1) ;=> "e"

;;; modules
;; gets variables from the module
(get <module> <var>) ;; value of a variable in a module

;;; In the future, vectors will be accessible by number and tables by arbitrary keys
#+END_SRC

However, for the majority of objects, including all instances user-defined classes, get simply
accesses the fields of thei object by their names.

*** DONE ~if~

#+BEGIN_SRC fn
;;; syntax - if
(if <obj>
    <then>
    <else>)
;;; where <then> and <else> are arbitrary expressions
#+END_SRC

~if~ is a conditional expression. If <obj> is not ~false~ or ~null~, then it evaluates <then> and returns
its value. Otherwise, it evaluates <else> and returns that value.

*** TODO ~import~

#+BEGIN_SRC fn
;;; syntax - import
(import <module>)
(import <module> 'as <name>)
;;; where
;; <module> is a module designator
;; <name> is a symbol
#+END_SRC

~import~ imports an external module as a global variable. The name of the created variable can be
provided via the 'as keyword parameter. It is <module> by default. Module import behavior differs in
interactive and non-interactive evaluation.

Importing a module non-interactively:

1. searches for <module> in the list of previously-imported modules
2. if <module> was loaded previously, reuse the existing module object.
3. otherwise, look in the search path for the file <module>.fn. 
4. If a file is found, initialize a new module object by evaluating it. Otherwise, emit an error.

In interactive mode, when a module is imported a second time, the timestamp of its source file is
checked. If the file has been modified since the last import, the module is reloaded.

The search path is ~./:/usr/local/lib/fn/modules/:/usr/lib/fn/modules/~. Paths are relative to the
directory of the file being evaluated.

*Impl. Status:* Import works, but currently overwrites existing module definitions regardless of mode.
Module names may not include slashes.

**** Future extension: filename imports

There need to be other ways to import modules. Perhaps strings could be used to indicate filenames: 

#+BEGIN_SRC fn
(import "../core/src.fn") ; automatically names the module src
src ;=><MODULE:src.fn>
(import "../core/src.fn" 'as local-mod)
#+END_SRC

*** TODO ~import-from~

#+BEGIN_SRC fn
;;; syntax - import
(import-from <module> <var-specs*>)
(import-from <module>)
;;; where
;; <module> is a module designator
;; <vars*> is a sequence of symbols and/or lists (<module-var> <new-var>)


;; generall, we recommend putting each imported symbol on its own line
(import-from str (split str-split) 
#+END_SRC

~import-from~ performs an *unqualified import* from the given module. That means that it copies bindings
from another module into the current one. Bindings are copied by reference in order to ensure that
immutable and dynamic variables work as expected. When the one-argument form is used, all symbols
are imported. This feature is intended mainly for interactive sessions and should be used sparingly
outside that context.

*Impl. Status:* Not implemented

*** DONE ~let~

#+BEGIN_SRC fn
;;; syntax - let
(let (<binding-specs*>)
  <body*>)
;;; where
;; <binding-specs*> is an even-length alternating sequence of symbols and expressions

;;; examples
(let (x 2
      y 3)
  (+ x y)) ;=> 5
;; example with a recursive function:
(let (f (fn (acc lst)
          (if (= lst [])
              acc
              (f (+ lst.hd acc) lst.tl))))
  (f 0 [1 2 3])) ;=> 6
#+END_SRC

~let~ is used to extend the current lexical environment with new variables. The body is evaluated
within the extension.

A binding specifier is a symbol followed by a value expression. Each binding specifier adds one
local variable with the provided symbol as a name. Its value is the result of evaluating the
expression.

When let is evaluated, the lexical environment is extended before any value expressions are
evaluated. This allows recursive function definitions. The value expressions are always evaluated in
the order they are provided provided.

*** DONE ~quasiquote~

#+BEGIN_SRC fn
;;; syntax - quasiquote
(quasiquote <expr>)
;;; or equivalently
`<expr>
;;; where <expr> is an arbitrary expression
#+END_SRC

~quasiquote~ performs quasiquotation of the provided expression. When applied to an ~unquote~
expression, that value of unquote expression is evaluated. When applied to a list, recurisvely
applies quasiquotation to the elements of the list. When applied to another type of expression,
quotes the expression.

In addition, a quasiquoted list may contain ~unquote-splice~ expressions. ~unquote-splice~ expressions
evaluated and return a list (an error is generated if the value is not a list). This list is spliced
into the rest of the quasiquoted list.

Nesting quasiquote changes unquote behavior. For each level of quasiquotation, an additional level
of unquotation is needed in order to trigger evaluation. Lower-levels of unquote and unquote-splice
expressions are quoted like normal lists.

*** DONE ~quote~

#+BEGIN_SRC fn
;;; syntax - quote
(quote <expr>)
;;; or equivalently
'<expr>

;;; examples:
;; quoting literals
'-2 ;=> -2
'"str" ;=> "str"
;; quoting symbols
'a ;=> a
'symbol ;=> symbol
;; quoting lists
'(+ 2 x) ;=> [+ 2 x]
'(String "x+3=" (+ x 3)) ;=> [String "x+3=" [+ x 3]]
#+END_SRC

~quote~ causes an expression's code to be returned as an fn value. This process is called *quoting*.

*** DONE ~set~

#+BEGIN_SRC fn
;;; syntax - quote
(set <var> <value>)
(set (get <obj> <keys*>) <value>)
#+END_SRC

~set~ is used to set variables and to mutate objects. When ~(set (get obj field))~ is used, the value of
field in object is mutated. Note that fields in user-defined classes are immutable by default, and
that all built-in classes are also immutable. (Note: tables and byte arrays will have mutable
fields).

*** DONE ~unquote~

#+BEGIN_SRC fn
;;; syntax - unquote
(unquote <expr>)
;;; or equivalently
,<expr>
#+END_SRC

~unquote~ is used within ~quasiquote~, where it causes its expression to be evaluated.

When ~unquote~ appears outside of ~quasiquote~, an error is generated.

*** DONE ~unquote-splice~

#+BEGIN_SRC fn
;;; syntax - unquote
(unquote-splice <expr>)
;;; or equivalently
,<expr>
#+END_SRC

~unquote-splice~ is used within quasiquoted lists, where it causes its expression to be evaluated and
spliced into the list.

When ~unquote-splice~ appears outside of a quasiquoted list, an error is generated.

** Standard library

Here we're working on defining a standard library for fn. This section is a work in progress and
will remain so for the forseeable future.

*** TODO Runtime (sys module)

*sys*
- (reload module)
- args
- (loaded-modules)
- (import-sym )

*** TODO Object manipulation

- =
- copy

*** TODO Control flow

- (for seq & body)
- (loop parameters init-args & body)
- ->, ->>, ->as
- comp
- and, or, not

*** TODO Macro Writing/Code Manipulation

- module code
- gensym
- walk-code

*** TODO Math

- +, -, /, *
- mod
- pow
- sqrt
- log
- floor
- ceil
- int-part
- frac-part
- int?
- even?
- odd?
- exp
- sin, cos, tan
- asin, acos, atan
- sinh, cosh, tanh
- asinh, acosh, atanh

- bit-and
- bit-or
- bit-xor
- bit-nand
- >>, <<

*** TODO Sequences and Collections

Many sequence functions have two versions, e.g. map and map0. The difference is that the version
without the zero returns a lazy list, while the other returns a regular list.

Sequence functions take a sequence object as their last argument.

- (head seq) :: first element of a sequence
- (tail seq) :: tail of a sequence
- (empty? seq) :: true if seq has no characters, false otherwise
- (cons elt seq) :: prepend an element to a list
- (conj coll elt0 & elts) :: efficiently, non-destructively add item(s) to a collection. The indices
     of the new items depend on the type of the collection.
- (contains? coll item (test =)) :: tell if coll contains an item
- (nth seq n) :: get nth item
- (find fun seq) :: return the first element in seq satisfying fun
- (take n seq), take0 :: get the first n items of seq as a lazy list/list
- (drop n seq), drop0 :: drop the first n items of seq and return the tail
- (take-while fun seq), take-while0 :: take all contiguous elements satisfying fun
- (drop-while fun seq), drop-while0 :: drop all contiguous elements satisfying fun
- (map fun seq0 & seqs), map0 :: apply a function to
- (filter fun seq), filter0
- (zip & seqs), zip0
- (group n seqs), group0
- (group-by fun seq), group-by0
- (interleave & seqs), interleave0
- (dedupe seq ('by =)), dedupe0
- (reverse seq)
- (foldl fun init seq)
- (foldr fun init seq)

*sequence creation*
- (cat & seqs), cat0
- (cycle & items)
- (repeat seq)
- (range a b (step 1)), range0

*** TODO Files and Streams

This should encompass all basic POSIX file functionality.

- io module
- File class
- print
- println

*** TODO Strings

*built-in*
- String
- show
- char-digit?
- char-ascii?
- char->int
- int->char

*str module*
- str-split, str-split0
- str-subst
- words, words0
- lines, lines0
- upcase
- downcase


* fn Coding Conventions 

** Names

*** Parameters and local variables

Function parameters and local variables should have short and sweet names that are easy to type
without being esoteric. The usual best practices apply:

- if you abbreviate something, use the same abbreviation everywhere
- avoid names of built-in functions and operators (e.g. naming a variable ~map~ or ~if~ is bad form)

Separate words with dashes.

*Common Abbreviations*

Use of the following names and abbreviations is encouraged:

*Types of objects:*
- obj  :: object (of an arbitrary class)
- arr  :: array (arrays are not yet implemented)
- ch   :: character (= string of length 1)
- fun  :: function
- int  :: integer
- num  :: number
- sym  :: symbol
- str  :: string
- tab  :: table (tables are not yet implemented)
*Code as data:*
- code :: quoted code
- expr :: expression (quoted code that will be evaluated)
- params :: quoted parameter list
*Sequences & collections*:
- coll :: collection
- ct   :: count
- *hd*   :: sequence head
- *tl*   :: sequence tail
- elt  :: element (of a collection)
- seq  :: sequence
- tab  :: table

*Do not:*
- abbreviate ~list~ as ~lst~. This isn't Scheme, and ~list~ with the lowercase ~l~ is not bound to anything
  by default.
- use CamelCase for any names. Use lisp-case (words separated by dashes) instead
- start variable names with upper case letters (with exceptions made for external naming
  conventions, see below)

*Dealing with external naming conventions*:

The motivation for this section is scientific computing. It is almost always the case that code in a
research paper, etc. has a set of canonical variable names in it. For instance, naming the energy
levels of a quantum system as E subscript a number. In this case, we encourage you to bend the above
variable conventions in order to maintain consistency with the jargon of the field. You should still
avoid name collisions with built-in functions and special operators just because of the insidious
bugs these can cause. To represent names with super- or subscripts, use LaTeX notation (_ for
subscripts and ^ for superscripts), with escaped braces for grouping. Before doing this, consider
whether the subscripted variable should really be a scalar value or if it should be a function
indexed container type. Greek letters may also use LaTeX notation. I plan to eventually add an
extension to neatly export fn source code as LaTeX (for writing up papers).

Example, using some common variables from physics

#+BEGIN_SRC fn
(def \\pi 3.141593)
(def h 6.626070e-34)
(def h-bar (/ h 2 \\pi))

;; use E_1 to denote the first energy level
;; use m for mass
(def (inf-well-width m E_1)
  (options 'type (Num Num -> Float))
  "Given the first energy level of an infinite square well, compute its width"
  (/ (* \\pi h-bar) (sqrt (* 2 m E_1))))

(defmacro (with-infix-math body)
  "Expand a function to use infix math.
#+END_SRC


*** Modules

Module names should consist only of lower-case characters and dashes.


*** Classes

Class names consist of one or more words separated by dashes.


*** Global functions and methods

*** Global mutable variables

*** Dynamic Variables


* Misc Notes and Ideas

This section is a bunch of garbage to help me remember things. (This is the clean garbage. The real
garbage is in a local directory).

If you're interested, the "proposals" below contain a lot of information about where I am/have been
in the various thought processes involved in designing this language. Hot proposals are ones I'll
probably incorporate into the language. "Explorations" are just stream-of-consciousness ramblings
(I guess proposal are too, but those have a purpose).

** Proposal: function options
** (Hot) Proposal: built-in anaphora

*Updated proposal 2019/09/05*

Anaphoric if, cond, and lambda are very handy. They are so useful, in fact, that I would like to
make the built-in versions anaphoric. However, when macroexpansions include anaphoric operators,
this would lead to sanitation problems, which we would most likely address by adding alternative,
non-anaphoric versions to be used exclusively in macroexpansions.

These are the proposed anaphoric forms. A convention is followed where implicitly bound variables
have names starting with "$", in keeping with ~$()~ syntax.

#+BEGIN_SRC fn
;; for our example, we use a lookup function that returns null on failure
(def my-plist ['key1 23 'key2 "hiya" 'key3 'lisp])
(def (get-value plist x)
  (if (= (head plist) x)
      (head (tail plist))
      null))

;; anaphoric if binds the variable $it to the result of the test
(def (if-test key)
  (if (get-value my-plist key)
      (String $it)
      "<missing>"))
(if-test 'key1) ;;=> "23.0"
(if-test 'key2) ;;=> "hiya"
(if-test 'not-even-a-key) ;;=> "<missing>"

;; anaphoric cond binds the variable $it in each one of its result clauses
(def (cond-test key1 key2)
  (cond
    (get-value my-plist key1) (String key1 "=" $it)
    (get-value my-plist key2) (String key2 "=" $it)
    true "no values"))
(cond-test 'key3 'key2) ;;=> "key3=lisp"
(cond-test 'lock1 'key1) ;;=> "key1=23.0"
(cond-test 'lock1 'lock2) ;;=> "no values"

;; anaphoric fn binds the variable $self to the function being created
(def (fn-test n)
  ;; compute factorial
  ((fn (acc i)
     (if (= i 0)
         acc
         ($self (* i acc) (- i 1))))
    1
    n))
(fn-test 2) ;;=>2.0
(fn-test 6) ;;=>720.0
#+END_SRC

These forms are no good for writing macros, so we need alternatives that do not create anaphoric
bindings. The only question is what to call them.

I suggest the names ~_if~, ~_cond~, and ~_fn~ for the sanitary versions. "m" may be a more appropriate
prefix than "\_" (e.g. ~mif~), but if we decide to make this a convention used for sanitary version of
macros, then it's clunkier; "_" is clearly not a part of the first word and doesn't appear in most
symbol names, which is why I lean in that direction.

Lastly, we consider the rule of anaphoric macros. In Common Lisp, it is very common to perform
lookup operations that return NIL on failure and the appropriate value on success. Since the
operation of checking for a key's existence is almost always coupled with getting its value, this
seems sensible. However, depending on how I end up designing pattern matching on tables, ~case~ might
make many of these usages unnecessary, making the built-in anaphora unnecessary. This would make the
language, and especially macro code, somewhat prettier.

Considering ~let~'s ability to bind recursive or even mutually-recursive functions, and since a ~loop~
macro similar to Clojure's (but supporting general recursion) will likely be introduced, anaphoric
~fn~ would have limited use.


*original proposal*

Anaphoric macros are so dang useful. I use AIF all over the place in my code. With that in mind,
here's a proposal: what if the built-in forms were anaphoric? The canonical name for test results is
IT in common lisp, for functions it's SELF, and for lets it's THIS. I'm not too concerned about
anaphoric let, but I could easily let ~if~ and ~cond~ to bind ~it~ and let ~fn~ and ~dollar-fn~ bind ~self~.
This would also make a ~loop~ macro entirely unnecessary:

#+BEGIN_SRC fn
;; proposed loop macro, used to reverse a list
(loop (acc src) ([] lst)
  (if (empty? src)
      acc
      (recur (cons (head src) acc) (tail src))))

;; equivalent expression with anaphoric fn
((fn (acc src)
   (if (empty? src)
       acc
       (self (cons (head src) acc) (tail src))))
 [] lst)
#+END_SRC

Adding the ~self~ binding to functions seems like a no-brainer. Adding ~it~ to ~if~, ~case~, and ~cond~ seems
like a good idea, too.

In the interest of preventing name collisions, the names ~$it~ and ~$self~ might probably be better.
This could also work as a convention: variables introduced by macro expansions should start with $.

When we start caring about performance, it's probably worth walking the code to see whether the
anaphoric variables should be bound at all.

** Proposal: change set name to set!

The Scheme/Racket naming convention for stateful functions is pretty good.

** Exploration: object internal representations

There are several different representations of objects in fn.

- List
- Record
- Vector (trie)
- Table (hash trie)
- (possibly?) Byte-Array
- (possibly?) Array

Suppose you could declare the internal representation of a class:

#+BEGIN_SRC fn
(defclass (Posix-Env & args)
  'doc "A set of environment variables."
  'representation Table
  )

(def (

(def (posix-env-var p str)
  (get (internals p) str))
#+END_SRC

** Exploration: forced sets of immutable objects

We could add an operator, called set!, set-forcefully, force-set, fset, or something like that. This
operator could mutate lists, tries, objects, etc that are normally immutable. (Currently, I like
force-set). This could even be used with conses. Downsides of this are that now we can fuck
ourselves in a wide variety of ways including potentially setting a cdr to a non-list value. This
complicates error reporting code.

** Proposal: module names and paths

Module search path should be ~./:/usr/local/lib/fn/modules:/usr/lib/fn/modules~. I will hard-code this
for now.

There are several ways to import another module:

#+BEGIN_SRC fn
;; import creates a module variable
(import sym)
(import sym-or-string 'as name)
;; import-from binds the specified names in the current module
(import-from sym-or-string (names))
#+END_SRC

Note that modules may be imported using either symbols or strings. In the latter case, the string
should be the pathname (either relative or absolute) of an fn source file, including the extension.
If a symbol is used, then the module is equal to 

*Impl. note:* import-from should use the same value cells in the new bindings as in the original
module. This causes changes from one variable to propagate to changes from another.

** Proposed pattern matching behavior

#+BEGIN_SRC fn
;;; syntax - case
(case <obj>
  <case-clauses*>)
;;; where
;; <case-clause> ::= <pattern> <expr>
#+END_SRC

A pattern is an expression that describes the structure of an object. A typical format for a pattern
is this:

#+BEGIN_SRC fn
(<class-name> <class-args>) 

;; e.g.
(defclass (Vec2 x y))
(def (on-axis? v)
  (case v
    (Vec2 0 _) true
    (Vec2 _ 0) true
    (Vec2 _ _) false))

(on-axis? (Vec2 3 0))   ;=> true
(on-axis? (Vec2 0 -2))  ;=> true
(on-axis? (Vec2 3 1))   ;=> false
(on-axis? 0)            ;=> runtime error
#+END_SRC

Unlike ~cond~, case will throw a runtime error if there are no matches.

Below is a description of every built-in pattern (where obj refers to the match object):

*Class and constant matchers:*
The patterns below match objects based on their type or exact value and bind no variables.
- ~<Num>~ :: Matches numbers equal to <Num>
- ~<String>~ :: Matches strings equal to <String>
- ~'<symbol>~ :: Matches symbols equal to symbols
- _ :: Wildcard pattern. Matches everything


- ~<symbol>~ :: (where symbol is not the wildcard _). Matches everything. Binds <symbol> to obj
- ~[<subpattern*>]~ :: List pattern. Matches Lists with the corresponding structure. (E.g. [] only
     matches the empty list, and [x y] only matches length-two lists). The elements of the list may
     be any valid pattern. On match, the variables from every subpattern are bound. Name collisions
     between any two subpatterns cause an error.
- ~[<subpattern*> & <tail-pattern>]~ :: Like the List pattern, but has a variadic pattern matching.
     The variadic parameter is matched as a list, so <tail-pattern> must match lists or the [&]
     pattern will never match anything.
- ~(<Class-Name> <subpattern*>)~ :: Matches an object based on the values of its fields. The structure
     of the sub-patterns should mirror the class's parameter list. There must be at least as many
     subpatterns as there are positional (including optional) parameters. These subpatterns will be
     checked for matches against the corresponding fields of the object. To do matching on keyword
     fields, simply put the quoted symbol as an argument to the pattern, followed immediately by the
     corresponding subpattern (similar to how keyword arguments are passed to the constructor). Not
     all keywords need to be provided. The ones which are omitted will be ignored. Finally, the
     structure of a variadic field can be matched to a pattern using & followed by the subpattern.

#+BEGIN_SRC fn
(case list
  ;; List patterns match lists that have the correct subpatterns as 
  []        nil      ; empty list
  [x y]     (+ x y)  ; list of exactly two elements
  [hd & tl] (map $(+ hd $) tl))  ; variadic argument

(defclass (Vec2 x y))

#+END_SRC

** Proposed extension: ~let~ pattern destructuring

#+BEGIN_SRC fn
;; code using current version of let
(let (left-right (split "foo,bar" ",")
      left left-right.hd
      right (get left-right 1))
  (String left " & " right)) ;=> "foo & bar"

;; proposed extension
(let ([left right] (split "foo,bar" ","))
  (String left " & " right)) ;=> "foo & bar"
#+END_SRC

In this extension, we allow ~case~-like pattern destructuring in ~let~ bindings.

A practical use of this extension would be to simulate multiple return values as shown in the
example above. A function with multiple return values would simply return them as a list, and ~let~
destructuring would make it convenient to recover the individual variables.

*** Q: Which patterns do we allow?

The one obvious requirement for patterns in let is that they have to bind variables.

There are three proposed "logical" patterns to be accepted by ~case~: ~satisfies?~, ~and~, and ~or~. The
first takes a function as an argument and matches if the function returns true when called with the
object as an argument. ~satisfies?~ binds no variables. ~and~ matches when all the patterns in its
arguments match and binds the last pattern's variables. ~or~ matches when any of the patterns in
its arguments match and binds no variables.

~let~ will not accept any logical patterns, as their behaviors are outside the scope of local variable
definition.

